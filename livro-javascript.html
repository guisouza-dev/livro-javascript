<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JavaScript Básico</title>
  <link rel="stylesheet" href="styles/style.css" media="screen">
  <link rel="stylesheet" href="styles/print.css" media="print">
</head>
<body>
  <div id="center">
    <h1>JavaScript Básico</h1>
    <h2 class="atx" id="sumario">Sumário</h2>
    <ul>
    <li><a href="#comentar-seu-codigo-javascript">Comentar seu código JavaScript</a></li>
    <li><a href="#declarar-variaveis-javascript">Declarar variáveis JavaScript</a></li>
    <li><a href="#armazenar-valores-com-o-operador-de-atribuicao">Armazenar valores com o operador de atribuição</a></li>
    <li><a href="#atribuir-o-valor-de-uma-variavel-para-outra">Atribuir o valor de uma variável para outra</a></li>
    <li><a href="#inicializar-variaveis-com-o-operador-de-atribuicao">Inicializar variáveis com o operador de atribuição</a></li>
    <li><a href="#declarar-variaveis-de-string">Declarar variáveis de string</a></li>
    <li><a href="#entender-variaveis-nao-inicializadas">Entender variáveis não inicializadas</a></li>
    <li><a href="#entender-a-sensibilidade-a-caracteres-maiusculos-e-minusculos-em-variaveis">Entender a sensibilidade a caracteres maiúsculos e minúsculos em variáveis</a></li>
    <li><a href="#diferenciar-entre-as-palavras-chave-var-e-let">Diferenciar entre as palavras-chave var e let</a></li>
    <li><a href="#declarar-variaveis-somente-de-leitura-com-a-palavra-chave-const">Declarar variáveis somente de leitura com a palavra-chave const</a></li>
    <li><a href="#adicionar-dois-numeros-com-javascript">Adicionar dois números com JavaScript</a></li>
    <li><a href="#subtrair-um-numero-de-outro-com-javascript">Subtrair um número de outro com JavaScript</a></li>
    <li><a href="#multiplicar-dois-numeros-com-javascript">Multiplicar dois números com JavaScript</a></li>
    <li><a href="#dividir-um-numero-por-outro-com-javascript">Dividir um número por outro com JavaScript</a></li>
    <li><a href="#incrementar-um-numero-com-javascript">Incrementar um número com JavaScript</a></li>
    <li><a href="#decrementar-um-numero-com-javascript">Decrementar um número com JavaScript</a></li>
    <li><a href="#criar-numeros-decimais-com-javascript">Criar números decimais com JavaScript</a></li>
    <li><a href="#multiplicar-dois-decimais-com-javascript">Multiplicar dois decimais com JavaScript</a></li>
    <li><a href="#dividir-um-decimal-por-outro-com-javascript">Dividir um decimal por outro com JavaScript</a></li>
    <li><a href="#descobrir-o-resto-em-javascript">Descobrir o resto em JavaScript</a></li>
    <li><a href="#atribuir-de-modo-composto-com-adicao-aumentada">Atribuir de modo composto com adição aumentada</a></li>
    <li><a href="#atribuir-de-modo-composto-com-subtracao-aumentada">Atribuir de modo composto com subtração aumentada</a></li>
    <li><a href="#atribuir-de-modo-composto-com-multiplicacao-aumentada">Atribuir de modo composto com multiplicação aumentada</a></li>
    <li><a href="#atribuir-de-modo-composto-com-divisao-aumentada">Atribuir de modo composto com divisão aumentada</a></li>
    <li><a href="#escapar-aspas-literais-em-strings">Escapar aspas literais em strings</a></li>
    <li><a href="#cercar-uma-string-com-aspas-simples">Cercar uma string com aspas simples</a></li>
    <li><a href="#escapar-sequencias-em-strings">Escapar sequências em strings</a></li>
    <li><a href="#concatenar-strings-com-o-operador-mais">Concatenar strings com o operador mais</a></li>
    <li><a href="#concatenar-strings-com-o-operador-mais-igual">Concatenar strings com o operador mais igual</a></li>
    <li><a href="#criar-strings-com-variaveis">Criar strings com variáveis</a></li>
    <li><a href="#adicionar-variaveis-para-strings">Adicionar variáveis para strings</a></li>
    <li><a href="#encontrar-o-tamanho-de-uma-string">Encontrar o tamanho de uma string</a></li>
    <li><a href="#usar-notacao-de-colchetes-para-encontrar-o-primeiro-caractere-em-uma-string">Usar notação de colchetes para encontrar o primeiro caractere em uma string</a></li>
    <li><a href="#estender-a-imutabilidade-das-strings">Entender a imutabilidade das strings</a></li>
    <li><a href="#usar-notacao-de-colchetes-para-encontrar-o-enesimo-caractere-em-uma-string">Usar notação de colchetes para encontrar o enésimo caractere em uma string</a></li>
    <li><a href="#usar-notacao-de-colchetes-para-encontrar-o-ultimo-caractere-em-uma-string">Usar notação de colchetes para encontrar o último caractere em uma string</a></li>
    <li><a href="#usar-notacao-de-colchetes-para-descobrir-o-enesimo-caractere-antes-do-ultimo-em-uma-string">Usar notação de colchetes para descobrir o enésimo caractere antes do último em uma string</a></li>
    <li><a href="#preencher-espacos-em-branco">Preencher espaços em branco</a></li>
    <li><a href="#armazenar-multiplos-valores-em-uma-variavel-usando-arrays-javascript">Armazenar múltiplos valores em uma variável usando arrays JavaScript</a></li>
    <li><a href="#aninhar-um-array-em-outro-array">Aninhar um array em outro array</a></li>
    <li><a href="#acessar-array-de-dados-com-indices">Acessar array de dados com índices</a></li>
    <li><a href="#modificar-dados-de-array-com-indices">Modificar dados de array com índices</a></li>
    <li><a href="#acessar-arrays-multidimensionais-com-indices">Acessar arrays multidimensionais com índices</a></li>
    <li><a href="#manipular-arrays-com-push">Manipular arrays com push()</a></li>
    <li><a href="#manipular-arrays-com-pop">Manipular arrays com pop()</a></li>
    <li><a href="#manipular-arrays-com-shift">Manipular arrays com shift()</a></li>
    <li><a href="#manipular-arrays-com-unshift">Manipular arrays com unshift()</a></li>
    <li><a href="#criar-lista-de-compras">Criar lista de compras</a></li>
    <li><a href="#escrever-javascript-reutilizavel-com-funcoes">Escrever JavaScript reutilizável com funções</a></li>
    <li><a href="#passar-valores-para-funcoes-com-argumentos">Passar valores para funções com argumentos</a></li>
    <li><a href="#retornar-um-valor-de-uma-funcao-com-return">Retornar um valor de uma função com return</a></li>
    <li><a href="#conhecer-o-escopo-global-e-funcoes">Conhecer o escopo global e funções</a></li>
    <li><a href="#conhecer-o-escopo-local-e-funcoes">Conhecer o escopo local e funções</a></li>
    <li><a href="#diferenciar-escopo-global-e-local-em-funcoes">Diferenciar escopo global e local em funções</a></li>
    <li><a href="#entender-o-valor-undefined-retornado-de-uma-funcao">Entender o valor undefined retornado de uma função</a></li>
    <li><a href="#atribuir-com-valor-retornado">Atribuir com o valor retornado</a></li>
    <li><a href="#ficar-na-linha">Ficar na linha</a></li>
    <li><a href="#entender-valores-booleanos">Entender valores booleanos</a></li>
    <li><a href="#usar-logica-condicional-com-instrucoes-if">Usar lógica condicional com instruções if</a></li>
    <li><a href="#comparar-com-o-operador-de-igualdade">Comparar com o operador de igualdade</a></li>
    <li><a href="#comparar-com-o-operador-de-igualdade-estrita">Comparar com o operador de igualdade estrita</a></li>
    <li><a href="#praticar-a-comparacao-de-diferentes-valores">Praticar a comparação de diferentes valores</a></li>
    <li><a href="#comparar-com-o-operador-de-desigualdade">Comparar com o operador de desigualdade</a></li>
    <li><a href="#comparar-com-o-operador-de-desigualdade-estrita">Comparar com o operador de desigualdade estrita</a></li>
    <li><a href="#comparar-com-o-operador-maior-que">Comparar com o operador maior que</a></li>
    <li><a href="#comparar-com-o-operador-maior-ou-igual">Comparar com o operador maior ou igual</a></li>
    <li><a href="#comparar-com-o-operador-menor-que">Comparar com o operador menor que</a></li>
    <li><a href="#comparar-com-o-operador-menor-ou-igual">Comparar com o operador menor ou igual</a></li>
    <li><a href="#comparar-com-o-operador-logico-and">Comparar com o operador lógico AND</a></li>
    <li><a href="#comparar-com-o-operador-logico-or">Comparar com o operador lógico OR</a></li>
    <li><a href="#introduzir-instrucoes-else">Introduzir instruções else</a></li>
    <li><a href="#introduzir-instrucoes-else-if">Introduzir instruções else if</a></li>
    <li><a href="#usar-a-ordem-logica-em-instrucoes-if-else">Usar a ordem lógica em instruções if else</a></li>
    <li><a href="#encadear-instrucoes-if-else">Encadear instruções if else</a></li>
    <li><a href="#selecionar-entre-varias-opcoes-com-instrucoes-switch">Selecionar entre várias opções com instruções switch</a></li>
    <li><a href="#adicionar-uma-opcao-padrao-em-instrucoes-switch">Adicionar uma opção padrão em instruções switch</a></li>
    <li><a href="#lidar-com-opcoes-identicas-em-instrucoes-switch">Lidar com várias opções idênticas em instruções switch</a></li>
    <li><a href="#substituir-cadeias-de-if-else-por-switch">Substituir cadeias de if else por switch</a></li>
    <li><a href="#retornar-valores-booleanos-das-funcoes">Retornar valores booleanos das funções</a></li>
    <li><a href="#retornar-o-padrao-inicial-para-funcoes">Retornar o padrão inicial para funções</a></li>
    <li><a href="#criar-objetos-javascript">Criar objetos JavaScript</a></li>
    <li><a href="#acessar-propriedades-de-objetos-com-notacao-de-pontos">Acessar propriedades de objetos com notação de pontos</a></li>
    <li><a href="#acessar-propriedades-de-objeto-com-notacao-de-colchetes">Acessar propriedades de objeto com notação de colchetes</a></li>
    <li><a href="#acessar-propriedades-de-objetos-com-variaveis">Acessar propriedades de objetos com variáveis</a></li>
    <li><a href="#atualizar-propriedades-do-objeto">Atualizar propriedades do objeto</a></li>
    <li><a href="#adicionar-novas-propriedades-para-um-objeto-javascript">Adicionar novas propriedades para um objeto JavaScript</a></li>
    <li><a href="#excluir-propriedades-de-um-objeto-javascript">Excluir propriedades de um objeto JavaScript</a></li>
    <li><a href="#usar-objetos-para-pesquisas">Usar objetos para pesquisas</a></li>
    <li><a href="#testar-objetos-por-propriedades">Testar objetos por propriedades</a></li>
    <li><a href="#manipular-objetos-complexos">Manipular objetos complexos</a></li>
    <li><a href="#acessar-objetos-aninhados">Acessar objetos aninhados</a></li>
    <li><a href="#acessar-arrays-aninhados">Acessar arrays aninhados</a></li>
    <li><a href="#iterar-com-lacos-while-em-javascript">Iterar com laços while em JavaScript</a></li>
    <li><a href="#iterar-com-lacos-for-em-javascript">Iterar com laços for em JavaScript</a></li>
    <li><a href="#iterar-numeros-impares-com-um-laco-for">Iterar números ímpares com um laço for</a></li>
    <li><a href="#contar-para-tras-com-um-laco-for">Contar para trás com um laço for</a></li>
    <li><a href="#iterar-atraves-de-um-array-com-laco-for">Iterar através de um array com laço for</a></li>
    <li><a href="#aninhar-lacos-for">Aninhar laços for</a></li>
    <li><a href="#iterar-com-lacos-dowhile-em-javascript">Iterar com laços do...while em JavaScript</a></li>
    <li><a href="#substituir-lacos-usando-recursao">Substituir laços usando recursão</a></li>
    <li><a href="#gerar-fracoes-aleatorias-com-javascript">Gerar frações aleatórias com JavaScript</a></li>
    <li><a href="#gerar-numeros-inteiros-aleatorios-com-javascript">Gerar números inteiros aleatórios com JavaScript</a></li>
    <li><a href="#gerar-numeros-inteiros-aleatorios-dentro-de-um-intervalo">Gerar números inteiros aleatórios dentro de um intervalo</a></li>
    <li><a href="#usar-a-funcao-parseint">Usar a função parseInt</a></li>
    <li><a href="#usar-a-funcao-parseint-com-um-radix">Usar a função parseInt com um radix</a></li>
    <li><a href="#usar-o-operador-condicional-ternario">Usar o operador condicional (ternário)</a></li>
    <li><a href="#usar-operadores-de-multiplas-condicoes-ternarios">Usar operadores de múltiplas condições (ternários)</a></li>
    </ul>
    <hr>
    <h6 class="atx" id="lesscentergreaterjavascript-basico"><center>JavaScript Básico</center></h6>
  </div>


  <div id="center">
    <main>
      <h2 class="atx" id="comentar-seu-codigo-javascript">Comentar seu código JavaScript</h2>
      <p>Comentários são linhas de código que JavaScript vai ignorar intencionalmente. Os comentários são uma ótima maneira de deixar anotações para você mesmo e para outras pessoas que mais tarde precisarão descobrir o que esse código faz.</p>
      <p>Existem duas maneiras de escrever comentários em JavaScript:</p>
      <p>Usar&nbsp;<code>//</code>&nbsp;dirá ao JavaScript para ignorar o resto do texto na linha atual. Isso é um comentário de uma linha:</p>
      <pre><code class="fenced-code-block language-js">// This is an in-line comment.</code></pre>
      <p>Você pode fazer um comentário de mais de uma linha, começando com&nbsp;<code>/*</code>&nbsp;e terminando com&nbsp;<code>*/</code>. Este é um comentário em várias linhas:</p>
      <pre><code class="fenced-code-block language-js">/* This is amulti-line comment */</code></pre>
      <hr>
      <h2 class="atx" id="declarar-variaveis-javascript">Declarar variáveis JavaScript</h2>
      <p>Na ciência da computação,&nbsp;dado&nbsp;é qualquer coisa que tenha significado para o computador. JavaScript fornece oito&nbsp;tipos de dados&nbsp;diferentes que são&nbsp;<code>undefined</code>,&nbsp;<code>null</code>,&nbsp;<code>boolean</code>,&nbsp;<code>string</code>,&nbsp;<code>symbol</code>,&nbsp;<code>bigint</code>,&nbsp;<code>number</code>&nbsp;e&nbsp;<code>object</code>.</p>
      <p>Por exemplo, os computadores distinguem números, como o número<code>12</code>, e&nbsp;<code>strings</code>, como o&nbsp;<code>"12"</code>,&nbsp;<code>"dog"</code>, ou<code>"123 cats"</code>, as quais são coleções de caracteres. Computadores podem realizar operações matemáticas em um número, mas não em uma string.</p>
      <p>Variáveis&nbsp;permitem aos computadores armazenar e manipular dados de forma dinâmica. Elas fazem isso usando uma "etiqueta" para apontar para o dado ao invés de usar o próprio dado. Qualquer um dos 8 tipos de dados pode ser armazenado em uma variável.</p>
      <p>Variáveis são similares às variáveis x e y utilizadas na matemática, o que significa que elas são simples nomes para representar os dados aos quais se referem. Variáveis de computador diferem das variáveis matemáticas porque elas podem armazenar diferentes valores em momentos diferentes.</p>
      <p>Dizemos ao JavaScript para criar ou declarar uma variável colocando a palavra-chave&nbsp;<code>var</code>&nbsp;na frente dela, dessa forma:</p>
      <pre><code class="fenced-code-block language-js">var ourName;</code></pre>
      <p>cria uma variável chamada&nbsp;<code>ourName</code>. Em JavaScript, terminamos uma instrução com ponto e vírgula. Nomes de variáveis podem ser formados por números, letras e&nbsp;<code>$</code>&nbsp;ou&nbsp;<code>_</code>, mas não podem conter espaços ou começar com um número.</p>
      <hr>
      <h2 class="atx" id="armazenar-valores-com-o-operador-de-atribuicao">Armazenar valores com o operador de atribuição</h2>
      <p>Em JavaScript, você pode armazenar um valor em uma variável com o operador de&nbsp;atribuição&nbsp;(<code>=</code>).</p>
      <pre><code class="fenced-code-block language-js">myVariable = 5;</code></pre>
      <p>Isso atribui um valor do tipo&nbsp;<code>Number</code>&nbsp;de&nbsp;<code>5</code>&nbsp;para&nbsp;<code>myVariable</code>.</p>
      <p>Se há qualquer cálculo à direita do operador&nbsp;<code>=</code>, esses cálculos são executados antes do valor ser atribuído à variável na esquerda do operador.</p>
      <pre><code class="fenced-code-block language-js">var myVar;
      myVar = 5;</code></pre>
      <p>Primeiro, esse código cria uma variável chamada&nbsp;<code>myVar</code>. Em seguida, o código atribui&nbsp;<code>5</code>&nbsp;para&nbsp;<code>myVar</code>. Agora, se&nbsp;<code>myVar</code>&nbsp;aparece novamente no código, o programa vai tratá-la como se fosse&nbsp;<code>5</code>.</p>
      <hr>
      <h2 class="atx" id="atribuir-o-valor-de-uma-variavel-para-outra">Atribuir o valor de uma variável para outra</h2>
      <p>Após um valor ser atribuído para uma variável usando o operador de&nbsp;atribuição, você pode atribuir o valor daquela variável para outra variável usando o operador de&nbsp;atribuição.</p>
      <pre><code class="fenced-code-block language-js">var myVar;
      myVar = 5;
      var myNum;
      myNum = myVar;</code></pre>
      <p>O código acima declara uma variável&nbsp;<code>myVar</code>&nbsp;sem valor, e então atribui a ela o valor&nbsp;<code>5</code>. Em seguida, uma variável chamada&nbsp;<code>myNum</code>&nbsp;é declarada sem valor. Depois, o conteúdo de&nbsp;<code>myVar</code>&nbsp;(o qual é&nbsp;<code>5</code>) é atribuído para a variável&nbsp;<code>myNum</code>. Agora,&nbsp;<code>myNum</code>&nbsp;também possui o valor de&nbsp;<code>5</code>.</p>
      <hr>
      <h2 class="atx" id="inicializar-variaveis-com-o-operador-de-atribuicao">Inicializar variáveis com o operador de atribuição</h2>
      <p>É comum&nbsp;inicializar&nbsp;a variável com um valor inicial na mesma linha em que é declarada.</p>
      <pre><code class="fenced-code-block language-js">var myVar = 0;</code></pre>
      <p>Cria uma nova variável chamada&nbsp;<code>myVar</code>&nbsp;e atribua o seu valor inicial como&nbsp;<code>0</code>.</p>
      <hr>
      <h2 class="atx" id="declarar-variaveis-de-string">Declarar variáveis de string</h2>
      <p>Anteriormente, você usou o seguinte código para declarar uma variável:</p>
      <pre><code class="fenced-code-block language-js">var myName;</code></pre>
      <p>Mas você também pode declarar uma variável string assim:</p>
      <pre><code class="fenced-code-block language-js">var myName = "your name";</code></pre>
      <p><code>"your name"</code>&nbsp;é chamado de&nbsp;string&nbsp;literal. Uma string literal, ou string, é uma série de 0 ou mais caracteres entre aspas simples ou duplas.</p>
      <hr>
      <h2 class="atx" id="entender-variaveis-nao-inicializadas">Entender variáveis não inicializadas</h2>
      <p>Quando as variáveis de JavaScript são declaradas, elas têm um valor inicial de&nbsp;<code>undefined</code>. Se você fizer uma operação matemática em uma variável&nbsp;<code>undefined</code>, seu resultado será&nbsp;<code>NaN</code>, o que significa que&nbsp;"Não é um número". Se você concatenar uma string com uma variável&nbsp;<code>undefined</code>, você receberá uma&nbsp;string&nbsp;com o valor&nbsp;<code>undefined</code>.</p>
      <hr>
      <h2 class="atx" id="entender-a-sensibilidade-a-caracteres-maiusculos-e-minusculos-em-variaveis">Entender a sensibilidade a caracteres maiúsculos e minúsculos em variáveis</h2>
      <p>Em JavaScript todas os nomes de variáveis e funções são sensíveis a caracteres maiúsculos e minúsculos. Isso significa que a capitalização importa.</p>
      <p><code>MYVAR</code>&nbsp;não é o mesmo que&nbsp;<code>MyVar</code>&nbsp;nem&nbsp;<code>myvar</code>. É possível ter diversas variáveis distintas com o mesmo nome mas com capitalização diferente. É extremamente recomendado pelo bem da clareza, que você&nbsp;<em>não</em>&nbsp;use esse recurso da linguagem.</p>
      <p><strong>Melhores práticas</strong></p>
      <p>Escreva nomes de variáveis em JavaScript em&nbsp;camelCase. Em&nbsp;camelCase, nomes de variáveis com mais de uma palavra possuem a primeira palavra toda em minúscula e a primeira letra de cada palavra subsequente capitalizada.</p>
      <hr>
      <h2 class="atx" id="diferenciar-entre-as-palavras-chave-var-e-let">Diferenciar entre as palavras-chave var e let</h2>
      <p>Um dos maiores problemas ao declarar variáveis com a palavra-chave&nbsp;<code>var</code>&nbsp;é que você pode sobrescrever facilmente declarações de variável:</p>
      <pre><code class="fenced-code-block language-js">var camper = "James";
      var camper = "David";
      console.log(camper);</code></pre>
      <p>No código acima, a variável&nbsp;<code>camper</code>&nbsp;é originalmente declarada com o valor&nbsp;<code>James</code>&nbsp;e então substituída pelo valor&nbsp;<code>David</code>. O console, então, vai exibir a string&nbsp;<code>David</code>.</p>
      <p>Em uma aplicação pequena, você pode não encontrar esse tipo de problema. Mas à medida que sua base de código se tornar maior, você pode sobrescrever acidentalmente uma variável que você não pretendia. Como esse comportamento não lança um erro, a busca e correção de bugs tornam-se mais difíceis.</p>
      <p>Uma palavra-chave chamada&nbsp;<code>let</code>&nbsp;foi introduzida na ES6, uma grande atualização para o JavaScript, para resolver este possível problema com a palavra-chave&nbsp;<code>var</code>. Você vai aprender sobre outros recursos da ES6 em desafios posteriores.</p>
      <p>Se você substituir&nbsp;<code>var</code>&nbsp;por&nbsp;<code>let</code>&nbsp;no código acima, ele resultará em um erro:</p>
      <pre><code class="fenced-code-block language-js">let camper = "James";
      let camper = "David";</code></pre>
      <p>O erro pode ser visto no console do seu navegador.</p>
      <p>Então, diferente de&nbsp;<code>var</code>, ao usar&nbsp;<code>let</code>, uma variável com o mesmo nome só pode ser declarada uma única vez.</p>
      <hr>
      <h2 class="atx" id="declarar-variaveis-somente-de-leitura-com-a-palavra-chave-const">Declarar variáveis somente de leitura com a palavra-chave const</h2>
      <p>A palavra-chave&nbsp;<code>let</code>&nbsp;não é a única nova forma de declarar variáveis. Na versão ES6, você também pode declarar variáveis usando a palavra-chave&nbsp;<code>const</code>.</p>
      <p><code>const</code>&nbsp;possui todos os recursos maravilhosos que&nbsp;<code>let</code>&nbsp;tem, com o bônus adicional que variáveis declaradas usando&nbsp;<code>const</code>&nbsp;são somente de leitura. Elas têm um valor constante, o que significa que a variável atribuída com&nbsp;<code>const</code>&nbsp;não pode ser atribuída novamente:</p>
      <pre><code class="fenced-code-block language-js">const FAV_PET = "Cats";
      FAV_PET = "Dogs";</code></pre>
      <p>O console vai exibir um erro devido à reatribuição do valor de&nbsp;<code>FAV_PET</code>.</p>
      <p>Você sempre deve nomear variáveis que você não quer reatribuir, usando a palavra-chave&nbsp;<code>const</code>. Isso ajuda quando você acidentalmente tenta reatribuir uma variável que deveria ser constante.</p>
      <p><strong>Observação:</strong>&nbsp;é comum que os desenvolvedores usem nomes de variáveis maiúsculas para valores imutáveis e minúsculas ou camelCase para valores mutáveis (objetos e arrays). Você aprenderá mais sobre objetos, arrays e valores imutáveis e mutáveis em desafios futuros. Em desafios posteriores, você também verá exemplos de identificadores de variáveis maiúsculas, minúsculas ou em camelCase.</p>
      <hr>
      <h2 class="atx" id="adicionar-dois-numeros-com-javascript">Adicionar dois números com JavaScript</h2>
      <p><code>Number</code>&nbsp;é um tipo de dado em JavaScript que representa um dado numérico.</p>
      <p>Agora, vamos tentar adicionar dois números usando JavaScript.</p>
      <p>JavaScript utiliza o símbolo&nbsp;<code>+</code>&nbsp;como um operador de adição quando colocado entre dois números.</p>
      <p><strong>Exemplo:</strong></p>
      <pre><code class="fenced-code-block language-js">const myVar = 5 + 10;</code></pre>
      <p><code>myVar</code>&nbsp;agora tem o valor de&nbsp;<code>15</code>.</p>
      <hr>
      <h2 class="atx" id="subtrair-um-numero-de-outro-com-javascript">Subtrair um número de outro com JavaScript</h2>
      <p>Nós também podemos subtrair um número de outro.</p>
      <p>JavaScript usa o símbolo&nbsp;<code>-</code>&nbsp;para subtração.</p>
      <p><strong>Exemplo</strong></p>
      <pre><code class="fenced-code-block language-js">const myVar = 12 - 6;</code></pre>
      <p><code>myVar</code>&nbsp;teria o valor&nbsp;<code>6</code>.</p>
      <hr>
      <h2 class="atx" id="multiplicar-dois-numeros-com-javascript">Multiplicar dois números com JavaScript</h2>
      <p>Nós também podemos multiplicar um número por outro.</p>
      <p>JavaScript usa o símbolo&nbsp;<code>*</code>&nbsp;para multiplicação de dois números.</p>
      <p><strong>Exemplo</strong></p>
      <pre><code class="fenced-code-block language-js">const myVar = 13 * 13;</code></pre>
      <p><code>myVar</code>&nbsp;teria o valor&nbsp;<code>169</code>.</p>
      <hr>
      <h2 class="atx" id="dividir-um-numero-por-outro-com-javascript">Dividir um número por outro com JavaScript</h2>
      <p>Nós também podemos dividir um número por outro.</p>
      <p>JavaScript usa o símbolo&nbsp;<code>/</code>&nbsp;para divisão.</p>
      <p><strong>Exemplo</strong></p>
      <pre><code class="fenced-code-block language-js">const myVar = 16 / 2;</code></pre>
      <p><code>myVar</code>&nbsp;agora possui o valor&nbsp;<code>8</code>.</p>
      <hr>
      <h2 class="atx" id="incrementar-um-numero-com-javascript">Incrementar um número com JavaScript</h2>
      <p>Você pode facilmente&nbsp;incrementar&nbsp;ou adicionar 1 à variável com o operador&nbsp;<code>++</code>.</p>
      <pre><code class="fenced-code-block language-js">i++;</code></pre>
      <p>é o equivalente a</p>
      <pre><code class="fenced-code-block language-js">i = i + 1;</code></pre>
      <p><strong>Observação:</strong>&nbsp;a linha inteira torna-se&nbsp;<code>i++;</code>, eliminando a necessidade para o sinal de igual (atribuição).</p>
      <hr>
      <h2 class="atx" id="decrementar-um-numero-com-javascript">Decrementar um número com JavaScript</h2>
      <p>Você pode facilmente&nbsp;decrementar&nbsp;ou diminuir uma variável por um com o operador&nbsp;<code>--</code>.</p>
      <pre><code class="fenced-code-block language-js">i--;</code></pre>
      <p>é o equivalente a</p>
      <pre><code class="fenced-code-block language-js">i = i - 1;</code></pre>
      <p><strong>Observação:</strong>&nbsp;a linha inteira torna-se&nbsp;<code>i--;</code>, eliminando a necessidade para o sinal de igual (atribuição).</p>
      <hr>
      <h2 class="atx" id="criar-numeros-decimais-com-javascript">Criar números decimais com JavaScript</h2>
      <p>Nós também podemos armazenar números decimais em variáveis. Números decimais são às vezes referidos como números de&nbsp;ponto flutuante&nbsp;ou&nbsp;floats.</p>
      <hr>
      <h2 class="atx" id="multiplicar-dois-decimais-com-javascript">Multiplicar dois decimais com JavaScript</h2>
      <p>Em JavaScript, você também pode realizar cálculos com números decimais, assim como com números inteiros.</p>
      <hr>
      <h2 class="atx" id="descobrir-o-resto-em-javascript">Descobrir o resto em JavaScript</h2>
      <p>O operador de&nbsp;resto&nbsp;<code>%</code>&nbsp;retorna o resto da divisão de dois números.</p>
      <p><strong>Exemplo</strong></p>
      <blockquote class="descobrir-resto">
      <p>5 % 2 = 1 porque<br>Math.floor(5 / 2) = 2 (Quociente)<br>2 * 2 = 4<br>5 - 4 = 1 (Resto)</p>
      </blockquote>
      <p><strong>Uso</strong><br>Na matemática, um número pode ser verificado como par ou ímpar por meio do resto da divisão do número por&nbsp;<code>2</code>.</p>
      <blockquote class="descobrir-resto">
      <p>17 % 2 = 1 (17 é Ímpar)<br>48 % 2 = 0 (48 é Par)</p>
      </blockquote>
      <p><strong>Observação:</strong>&nbsp;o operador de&nbsp;resto&nbsp;às vezes é referido incorretamente como o operador de módulo. É muito semelhante ao módulo, mas não funciona adequadamente com números negativos.</p>
      <hr>
      <h2 class="atx" id="atribuir-de-modo-composto-com-adicao-aumentada">Atribuir de modo composto com adição aumentada</h2>
      <p>Na programação, é comum usar atribuições para modificar o conteúdo de uma variável. Lembre-se de que tudo à direita do sinal de igual é avaliado primeiro, para que possamos dizer:</p>
      <pre><code class="fenced-code-block language-js">myVar = myVar + 5;</code></pre>
      <p>para adicionar&nbsp;<code>5</code>&nbsp;a&nbsp;<code>myVar</code>. Como este é um padrão tão comum, existem operadores que realizam uma operação matemática e atribuição em um passo.</p>
      <p>Um desses operadores é o operador&nbsp;<code>+=</code>.</p>
      <pre><code class="fenced-code-block language-js">let myVar = 1;
      myVar += 5;
      console.log(myVar);</code></pre>
      <p><code>6</code>&nbsp;seria exibido no console.</p>
      <hr>
      <h2 class="atx" id="atribuir-de-modo-composto-com-subtracao-aumentada">Atribuir de modo composto com subtração aumentada</h2>
      <p>Como o operador&nbsp;<code>+=</code>,&nbsp;<code>-=</code>&nbsp;subtrai um número de uma variável.</p>
      <pre><code class="fenced-code-block language-js">myVar = myVar - 5;</code></pre>
      <p>vai subtrair&nbsp;<code>5</code>&nbsp;de&nbsp;<code>myVar</code>. Essa expressão pode ser reescrita assim:</p>
      <pre><code class="fenced-code-block language-js">myVar -= 5;</code></pre>
      <hr>
      <h2 class="atx" id="atribuir-de-modo-composto-com-multiplicacao-aumentada">Atribuir de modo composto com multiplicação aumentada</h2>
      <p>O operador&nbsp;<code>*=</code>&nbsp;multiplica uma variável por um número.</p>
      <pre><code class="fenced-code-block language-js">myVar = myVar * 5;</code></pre>
      <p>multiplicará&nbsp;<code>myVar</code>&nbsp;por&nbsp;<code>5</code>. Essa expressão pode ser reescrita assim:</p>
      <pre><code class="fenced-code-block language-js">myVar *= 5;</code></pre>
      <hr>
      <h2 class="atx" id="atribuir-de-modo-composto-com-divisao-aumentada">Atribuir de modo composto com divisão aumentada</h2>
      <p>O operador&nbsp;<code>/=</code>&nbsp;divide uma variável por outro número.</p>
      <pre><code class="fenced-code-block language-js">myVar = myVar / 5;</code></pre>
      <p>dividirá&nbsp;<code>myVar</code>&nbsp;por&nbsp;<code>5</code>. Essa expressão pode ser reescrita assim:</p>
      <pre><code class="fenced-code-block language-js">myVar /= 5;</code></pre>
      <hr>
      <h2 class="atx" id="escapar-aspas-literais-em-strings">Escapar aspas literais em strings</h2>
      <p>Quando você estiver definindo uma sequência de caracteres você deve iniciar e terminar com uma aspa simples ou dupla. O que acontece quando você precisa de uma aspa literal:&nbsp;<code>"</code>&nbsp;ou&nbsp;<code>'</code>&nbsp;dentro de sua string?</p>
      <p>Em JavaScript, você pode&nbsp;escapar&nbsp;uma aspa para que não seja considerada como o fim de uma string ao colocar a&nbsp;barra invertida&nbsp;(<code>\</code>) na frente da aspa.</p>
      <pre><code class="fenced-code-block language-js">const sampleStr = "Alan said, \"Peter is learning JavaScript\".";</code></pre>
      <p>Isso sinaliza ao JavaScript que a aspa seguinte não é o fim de uma string, mas que deve aparecer dentro da string. Então, se você fosse imprimir isso no console, você obteria:</p>
      <pre><code class="fenced-code-block language-js">Alan said, "Peter is learning JavaScript".</code></pre>
      <hr>
      <h2 class="atx" id="cercar-uma-string-com-aspas-simples">Cercar uma string com aspas simples</h2>
      <p>Valores de&nbsp;string&nbsp;em JavaScript podem ser escritas com aspas simples ou duplas, desde que você comece e termine com o mesmo tipo de aspas. Diferente de outras linguagens de programação, aspas simples e duplas funcionam da mesma forma em JavaScript.</p>
      <pre><code class="fenced-code-block language-js">const doubleQuoteStr = "This is a string";
      const singleQuoteStr = 'This is also a string';</code></pre>
      <p>O motivo pelo qual você pode querer usar um tipo de aspas no lugar da outra é se você vir a querer usar ambas em uma string. Isso pode acontecer se você quiser salvar uma conversa em uma string e ter a conversa entre aspas. Outro uso para isso seria salvar uma tag&nbsp;<code>&lt;a&gt;</code>&nbsp;com vários atributos em aspas, tudo dentro de uma string.</p>
      <pre><code class="fenced-code-block language-js">const conversation = 'Finn exclaims to Jake, "Algebraic!"';</code></pre>
      <p>Porém, isso se torna um problema se você precisar usar as aspas mais extremas dentro dela. Lembre-se, uma string tem o mesmo tipo de aspas no início e no final. Mas se você tem aquela mesma aspa em algum lugar no meio, a string vai terminar mais cedo e lançará um erro.</p>
      <pre><code class="fenced-code-block language-js">const goodStr = 'Jake asks Finn, "Hey, let\'s go on an adventure?"';
      const badStr = 'Finn responds, "Let's go!"';</code></pre>
      <p>Aqui&nbsp;<code>badStr</code>&nbsp;lançará um erro.</p>
      <p>Na string&nbsp;goodStr&nbsp;acima, você pode usar ambas as aspas com segurança ao usar a barra invertida&nbsp;<code>\</code>&nbsp;como um caractere de escapamento.</p>
      <p><strong>Observação:</strong>&nbsp;a barra invertida&nbsp;<code>\</code>&nbsp;não deve ser confundida com a barra comum&nbsp;<code>/</code>. Elas não fazem a mesma coisa.</p>
      <hr>
      <h2 class="atx" id="escapar-sequencias-em-strings">Escapar sequências em strings</h2>
      <p>Aspas não são os únicos caracteres que podem ser&nbsp;escapados&nbsp;dentro de uma string. Há dois motivos para usar caracteres de escapamento:</p>
      <ol>
      <li>Para permitir que você use caracteres que você pode não ser capaz de digitar do contrário, como o caractere de retorno de carro.</li>
      <li>Para permitir que você represente várias aspas em uma string sem o JavaScript entender erroneamente o que você quis dizer.</li>
      </ol>
      <p>Aprendemos isso no desafio anterior.</p>
      <table>
      <thead>
      <tr>
      <th>Código</th>
      <th>Saída</th>
      </tr>
      </thead>
      <tbody><tr>
      <td><code>\'</code></td>
      <td>aspas simples</td>
      </tr>
      <tr>
      <td><code>\"</code></td>
      <td>aspas duplas</td>
      </tr>
      <tr>
      <td><code>\</code></td>
      <td>barra invertida</td>
      </tr>
      <tr>
      <td><code>\n</code></td>
      <td>nova linha</td>
      </tr>
      <tr>
      <td><code>\r</code></td>
      <td>retorno de carro</td>
      </tr>
      <tr>
      <td><code>\t</code></td>
      <td>tab</td>
      </tr>
      <tr>
      <td><code>\b</code></td>
      <td>limite de palavra</td>
      </tr>
      <tr>
      <td><code>\f</code></td>
      <td>quebra de página</td>
      </tr>
      </tbody></table>
      <p><em>Note que a própria barra invertida deve ser escapada para ser exibida como uma barra invertida.</em></p>
      <hr>
      <h2 class="atx" id="concatenar-strings-com-o-operador-mais">Concatenar strings com o operador mais</h2>
      <p>Em JavaScript, quando o operador&nbsp;<code>+</code>&nbsp;é usado com um valor de&nbsp;<code>String</code>, ele é chamado de operador de&nbsp;concatenação. Você pode criar uma nova string a partir de outras strings ao&nbsp;concatenar&nbsp;elas juntos.</p>
      <p><strong>Exemplo</strong></p>
      <pre><code class="fenced-code-block language-js">'My name is Alan,' + ' I concatenate.'</code></pre>
      <p><strong>Observação:</strong>&nbsp;cuidado com os espaços. A concatenação não adiciona espaços entre strings concatenadas, então você mesmo precisará adicioná-las.</p>
      <p>Exemplo:</p>
      <pre><code class="fenced-code-block language-js">const ourStr = "I come first. " + "I come second.";</code></pre>
      <p>A string&nbsp;<code>I come first. I come second.</code>&nbsp;seria exibida no console.</p>
      <hr>
      <h2 class="atx" id="concatenar-strings-com-o-operador-mais-igual">Concatenar strings com o operador mais igual</h2>
      <p>Também podemos usar o operador&nbsp;<code>+=</code>&nbsp;para&nbsp;concatenar&nbsp;uma string no final de uma variável string existente. Isso pode ser muito útil para quebrar uma longa string em várias linhas.</p>
      <p><strong>Observação:</strong>&nbsp;cuidado com os espaços. A concatenação não adiciona espaços entre strings concatenadas, então você mesmo precisará adicioná-los.</p>
      <p>Exemplo:</p>
      <pre><code class="fenced-code-block language-js">let ourStr = "I come first. ";
      ourStr += "I come second.";</code></pre>
      <p><code>ourStr</code>&nbsp;agora deve ter como valor a string&nbsp;<code>I come first. I come second.</code>.</p>
      <hr>
      <h2 class="atx" id="criar-strings-com-variaveis">Criar strings com variáveis</h2>
      <p>Às vezes, você precisará criar uma string. Usando o operador de concatenação (<code>+</code>), você pode inserir uma ou mais variáveis em uma string que você está criando.</p>
      <p>Exemplo:</p>
      <pre><code class="fenced-code-block language-js">const ourName = "freeCodeCamp";
      const ourStr = "Hello, our name is " + ourName + ", how are you?";</code></pre>
      <p><code>ourStr</code>&nbsp;teria o valor da string&nbsp;<code>Hello, our name is freeCodeCamp, how are you?</code>.</p>
      <hr>
      <h2 class="atx" id="adicionar-variaveis-para-strings">Adicionar variáveis para strings</h2>
      <p>Assim como podemos construir uma string em várias linhas através das strings&nbsp;literais, nós também podemos adicionar as variáveis para a string usando o operador mais igual (<code>+=</code>).</p>
      <p>Exemplo:</p>
      <pre><code class="fenced-code-block language-js">const anAdjective = "awesome!";
      let ourStr = "freeCodeCamp is ";
      ourStr += anAdjective;</code></pre>
      <p><code>ourStr</code>&nbsp;teria o valor&nbsp;<code>freeCodeCamp is awesome!</code>.</p>
      <hr>
      <h2 class="atx" id="encontrar-o-tamanho-de-uma-string">Encontrar o tamanho de uma string</h2>
      <p>Você pode encontrar o tamanho de um valor de&nbsp;<code>String</code>&nbsp;ao escrever&nbsp;<code>.length</code>&nbsp;após a variável de string ou literal de string.</p>
      <pre><code class="fenced-code-block language-js">console.log("Alan Peter".length);</code></pre>
      <p>O valor&nbsp;<code>10</code>&nbsp;seria exibido no console. Observe que o caractere de espaço entre "Alan" e "Peter" também é contado.</p>
      <p>Por exemplo, se nós criássemos uma variável&nbsp;<code>const firstName = "Ada"</code>, poderíamos descobrir qual o tamanho da string&nbsp;<code>Ada</code>&nbsp;usando a propriedade&nbsp;<code>firstName.length</code>.</p>
      <hr>
      <h2 class="atx" id="usar-notacao-de-colchetes-para-encontrar-o-primeiro-caractere-em-uma-string">Usar notação de colchetes para encontrar o primeiro caractere em uma string</h2>
      <p>Notação de colchetes&nbsp;é uma forma de pegar um caractere no índice especificado dentro de uma string.</p>
      <p>A maioria das linguagens de programação modernas, como JavaScript, não começa contando do 1 como humanos fazem. Elas começam no 0. Isso é referido como indexação&nbsp;baseada em zero.</p>
      <p>Por exemplo, o caractere no índice 0 da palavra&nbsp;<code>Charles</code>&nbsp;é&nbsp;<code>C</code>. Então, se&nbsp;<code>const firstName = "Charles"</code>, você pode pegar o valor da primeira letra da string usando&nbsp;<code>firstName[0]</code>.</p>
      <p>Exemplo:</p>
      <pre><code class="fenced-code-block language-js">const firstName = "Charles";
      const firstLetter = firstName[0];</code></pre>
      <p><code>firstLetter</code>&nbsp;teria o valor da string&nbsp;<code>C</code>.</p>
      <hr>
      <h2 class="atx" id="entender-a-imutabilidade-das-strings">Entender a imutabilidade das strings</h2>
      <p>Em JavaScript, valores&nbsp;<code>String</code>&nbsp;são&nbsp;imutáveis, o que significa que elas não podem ser alteradas após serem criadas.</p>
      <p>Por exemplo, o código a seguir produzirá um erro porque a letra&nbsp;<code>B</code>&nbsp;na cadeia de caracteres&nbsp;<code>Bob</code>&nbsp;não pode ser alterada para a letra&nbsp;<code>J</code>:</p>
      <pre><code class="fenced-code-block language-js">let myStr = "Bob";
      myStr[0] = "J";</code></pre>
      <p>Observe que isso&nbsp;<em>não</em>&nbsp;significa que&nbsp;<code>myStr</code>&nbsp;não possa ser reatribuída. A única forma de alterar&nbsp;<code>myStr</code>&nbsp;seria atribuindo a ela um novo valor, deste modo:</p>
      <pre><code class="fenced-code-block language-js">let myStr = "Bob";
      myStr = "Job";</code></pre>
      <hr>
      <h2 class="atx" id="usar-notacao-de-colchetes-para-encontrar-o-enesimo-caractere-em-uma-string">Usar notação de colchetes para encontrar o enésimo caractere em uma string</h2>
      <p>ocê também pode usar&nbsp;notação de colchetes&nbsp;para pegar caracteres em outras posições em uma string.</p>
      <p>Lembre-se de que computadores começam contando do&nbsp;<code>0</code>. Então, o primeiro caractere é na verdade o caractere na posição 0.</p>
      <p>Exemplo:</p>
      <pre><code class="fenced-code-block language-js">const firstName = "Ada";
      const secondLetterOfFirstName = firstName[1];</code></pre>
      <p><code>secondLetterOfFirstName</code>&nbsp;teria o valor da string&nbsp;<code>d</code>.</p>
      <hr>
      <h2 class="atx" id="usar-a-notacao-de-colchetes-para-encontrar-o-ultimo-caractere-em-uma-string">Usar a notação de colchetes para encontrar o último caractere em uma string</h2>
      <p>Para pegar a última letra de uma string, você pode subtrair um do tamanho da string.</p>
      <p>Por exemplo, se&nbsp;<code>const firstName = "Ada"</code>, você pode pegar o valor da última letra da string ao usar&nbsp;<code>firstName[firstName.length - 1]</code>.</p>
      <p>Exemplo:</p>
      <pre><code class="fenced-code-block language-js">const firstName = "Ada";
      const lastLetter = firstName[firstName.length - 1];</code></pre>
      <p><code>lastLetter</code>&nbsp;teria o valor da string&nbsp;<code>a</code>.</p>
      <hr>
      <h2 class="atx" id="usar-a-notacao-de-colchetes-para-descobrir-o-enesimo-caractere-antes-do-ultimo-em-uma-string">Usar a notação de colchetes para descobrir o enésimo caractere antes do último em uma string</h2>
      <p>Você pode usar o mesmo princípio que nós acabamos de usar para recuperar o último caractere em uma string, para recuperar o enésimo caractere antes do último caractere.</p>
      <p>Por exemplo, você pode pegar o valor da antepenúltima letra da string&nbsp;<code>const firstName = "Augusta"</code>&nbsp;usando&nbsp;<code>firstName[firstName.length - 3]</code></p>
      <p>Exemplo:</p>
      <pre><code class="fenced-code-block language-js">const firstName = "Augusta";
      const thirdToLastLetter = firstName[firstName.length - 3];</code></pre>
      <p><code>thirdToLastLetter</code>&nbsp;teria o valor da string&nbsp;<code>s</code>.</p>
      <hr>
      <h2 class="atx" id="preencher-espacos-em-branco">Preencher espaços em branco</h2>
      <p>Você recebe frases com algumas palavras faltando, como substantivos, verbos, adjetivos e advérbios. Você então preencherá os pedaços faltantes com palavras de sua escolha de modo que a frase completa faça sentido.</p>
      <p>Considere a frase - Era realmente&nbsp;<strong>____</strong>&nbsp;e nós&nbsp;<strong>____</strong>&nbsp;nós mesmos&nbsp;<strong>____</strong>. Essa frase possui três pedaços faltando - um adjetivo, um verbo e um advérbio, e nós podemos adicionar palavras de nossa escolha para completar. Em seguida, podemos atribuir a frase completa para uma variável como se segue:</p>
      <pre><code class="fenced-code-block language-js">const sentence = "It was really " + "hot" + ", and we " + "laughed" + " ourselves " + "silly" + ".";</code></pre>
      <hr>
      <h2 class="atx" id="armazenar-multiplos-valores-em-uma-variavel-usando-arrays-javascript">Armazenar múltiplos valores em uma variável usando arrays JavaScript</h2>
      <p>Com as variáveis de&nbsp;<code>array</code>&nbsp;em JavaScript, podemos armazenar diversos dados em um único lugar.</p>
      <p>Você começa uma declaração de um array com a abertura de um colchetes, terminando com o fechamento do colchetes e colocando vírgulas entre cada entrada, dessa forma:</p>
      <pre><code class="fenced-code-block language-js">const sandwich = ["peanut butter", "jelly", "bread"];</code></pre>
      <hr>
      <h2 class="atx" id="aninhar-um-array-em-outro-array">Aninhar um array em outro array</h2>
      <p>Você também pode aninhar arrays dentro de outros arrays, como abaixo:</p>
      <pre><code class="fenced-code-block language-js">const teams = [["Bulls", 23], ["White Sox", 45]];</code></pre>
      <p>Isso é chamado um&nbsp;array multidimensional.</p>
      <hr>
      <h2 class="atx" id="acessar-array-de-dados-com-indices">Acessar array de dados com índices</h2>
      <p>Podemos acessar os dados dentro de arrays usando&nbsp;indexes.</p>
      <p>Os índices de um array são escritos na mesma notação com colchetes que as strings usam. Porém, em vez de especificar um caractere, eles estão especificando um item do array. Assim como ocorre com as strings, os arrays usam indexação&nbsp;de base zero, de forma que o primeiro elemento de um array possui índice&nbsp;<code>0</code>.</p>
      <p><strong>Exemplo</strong></p>
      <pre><code class="fenced-code-block language-js">const array = [50, 60, 70];
      console.log(array[0]);
      const data = array[1];</code></pre>
      <p>O&nbsp;<code>console.log(array[0])</code>&nbsp;exibirá&nbsp;<code>50</code>&nbsp;e&nbsp;<code>data</code>&nbsp;terá o valor de&nbsp;<code>60</code>.</p>
      <hr>
      <h2 class="atx" id="modificar-dados-de-array-com-indices">Modificar dados de array com índices</h2>
      <p>Ao contrário das strings, as entradas de arrays são&nbsp;mutáveis&nbsp;e podem ser alteradas livremente, mesmo se o array foi declarado com&nbsp;<code>const</code>.</p>
      <p><strong>Exemplo</strong></p>
      <pre><code class="fenced-code-block language-js">const ourArray = [50, 40, 30];
      ourArray[0] = 15;</code></pre>
      <p><code>ourArray</code>&nbsp;agora tem o valor&nbsp;<code>[15, 40, 30]</code>.</p>
      <p><strong>Observação:</strong>&nbsp;não deve haver espaços entre o nome do array e os colchetes, como&nbsp;<code>array [0]</code>. Embora JavaScript seja capaz de processar isso corretamente, isso pode confundir outros programadores lendo seu código.</p>
      <hr>
      <h2 class="atx" id="acessar-arrays-multidimensionais-com-indices">Acessar arrays multidimensionais com índices</h2>
      <p>Uma maneira de pensar em um array&nbsp;multidimensional&nbsp;é como um&nbsp;<em>array de arrays</em>. Quando você usa colchetes para acessar seu array, o primeiro conjunto de colchetes se refere às entradas no array mais exterior (o primeiro nível), e cada par adicional de colchetes refere-se ao próximo nível de entradas interno.</p>
      <p><strong>Exemplo</strong></p>
      <pre><code class="fenced-code-block language-js">const arr = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9],
        [[10, 11, 12], 13, 14]
      ];
      const subarray = arr[3];
      const nestedSubarray = arr[3][0];
      const element = arr[3][0][1];</code></pre>
      <p>Neste exemplo,&nbsp;<code>subarray</code>&nbsp;tem o valor de&nbsp;<code>[[10, 11, 12], 13, 14]</code>,&nbsp;<code>nestedSubarray</code>&nbsp;tem o valor de&nbsp;<code>[10, 11, 12]</code>&nbsp;e&nbsp;<code>element</code>&nbsp;tem o valor de&nbsp;<code>11</code>&nbsp;.</p>
      <p><strong>Observação:</strong>&nbsp;não deve haver nenhum espaço entre o nome do array e os colchetes como&nbsp;<code>array [0][0]</code>&nbsp;e até mesmo&nbsp;<code>array [0] [0]</code>&nbsp;não é permitido. Embora JavaScript seja capaz de processar isso corretamente, isso pode confundir outros programadores lendo seu código.</p>
      <hr>
      <h2 class="atx" id="manipular-arrays-com-push">Manipular arrays com push()</h2>
      <p>Uma forma fácil de adicionar dados no final de um array é através da função&nbsp;<code>push()</code>.</p>
      <p><code>.push()</code>&nbsp;recebe um ou mais&nbsp;parâmetros&nbsp;e "empurra" eles no final do array.</p>
      <p>Exemplos:</p>
      <pre><code class="fenced-code-block language-js">const arr1 = [1, 2, 3];
      arr1.push(4);
      const arr2 = ["Stimpson", "J", "cat"];
      arr2.push(["happy", "joy"]);</code></pre>
      <p><code>arr1</code>&nbsp;agora tem o valor de&nbsp;<code>[1, 2, 3, 4]</code>&nbsp;e&nbsp;<code>arr2</code>&nbsp;tem o valor de&nbsp;<code>["Stimpson", "J", "cat", ["happy", "joy"]]</code>.</p>
      <hr>
      <h2 class="atx" id="manipular-arrays-com-pop">Manipular arrays com pop()</h2>
      <p>Outra forma de alterar os dados em um array é com a função&nbsp;<code>.pop()</code>.</p>
      <p><code>.pop()</code>&nbsp;é usado para remover um valor do final do array. Nós podemos armazenar esse valor removido atribuindo-o a uma variável. Em outras palavras,&nbsp;<code>.pop()</code>&nbsp;remove o último elemento de um array e retorna aquele elemento.</p>
      <p>Qualquer tipo de entrada pode ser removida de um array - numbers, strings e até mesmo arrays aninhados.</p>
      <pre><code class="fenced-code-block language-js">const threeArr = [1, 4, 6];
      const oneDown = threeArr.pop();
      console.log(oneDown);
      console.log(threeArr);</code></pre>
      <p>O primeiro&nbsp;<code>console.log</code>&nbsp;exibirá o valor&nbsp;<code>6</code>&nbsp;e o segundo exibirá o valor&nbsp;<code>[1, 4]</code>.</p>
      <hr>
      <h2 class="atx" id="manipular-arrays-com-shift">Manipular arrays com shift()</h2>
      <p><code>pop()</code>&nbsp;sempre remove o último elemento de um array. E se você quiser remover o primeiro?</p>
      <p>É aí que o&nbsp;<code>.shift()</code>&nbsp;vem a ser útil. Ele funciona da mesma forma que&nbsp;<code>.pop()</code>, exceto que ele remove o primeiro elemento ao invés do último.</p>
      <p>Exemplo:</p>
      <pre><code class="fenced-code-block language-js">const ourArray = ["Stimpson", "J", ["cat"]];
      const removedFromOurArray = ourArray.shift();</code></pre>
      <p><code>removedFromOurArray</code>&nbsp;teria o valor da string&nbsp;<code>Stimpson</code>&nbsp;e&nbsp;<code>ourArray</code>&nbsp;teria o valor de&nbsp;<code>["J", ["cat"]]</code>.</p>
      <hr>
      <h2 class="atx" id="manipular-arrays-com-unshift">Manipular arrays com unshift()</h2>
      <p>Você pode não apenas usar&nbsp;<code>shift</code>&nbsp;para remover elementos do início de um array, como também pode usar&nbsp;<code>unshift</code>&nbsp;para adicionar elementos ao início de um array, ou seja, adicionar elementos na posição inicial do array.</p>
      <p><code>.unshift()</code>&nbsp;funciona exatamente como&nbsp;<code>.push()</code>, mas, ao invés de adicionar o elemento ao final do array,&nbsp;<code>unshift()</code>&nbsp;adiciona o elemento no início do array.</p>
      <p>Exemplo:</p>
      <pre><code class="fenced-code-block language-js">const ourArray = ["Stimpson", "J", "cat"];
      ourArray.shift();
      ourArray.unshift("Happy");</code></pre>
      <p>Após o&nbsp;<code>shift</code>,&nbsp;<code>ourArray</code>&nbsp;teria o valor&nbsp;<code>["J","cat"]</code>. Após o&nbsp;<code>unshift</code>,&nbsp;<code>ourArray</code>&nbsp;teria o valor&nbsp;<code>["Happy","J","cat"]</code>.</p>
      <hr>
      <h2 class="atx" id="escrever-javascript-reutilizavel-com-funcoes">Escrever JavaScript reutilizável com funções</h2>
      <p>Em JavaScript, nós podemos dividir nosso código em partes reutilizáveis chamadas de&nbsp;funções.</p>
      <p>Aqui está um exemplo de uma função:</p>
      <pre><code class="fenced-code-block language-js">function functionName() {
        console.log("Hello World");
      }</code></pre>
      <p>Você pode chamar ou&nbsp;invocar&nbsp;essa função ao usar seu nome seguido de parênteses, da seguinte forma:&nbsp;<code>functionName();</code>&nbsp;Cada vez que a função é chamada, imprimirá no console a mensagem&nbsp;<code>Hello World</code>. Todo o código entre as chaves será executado toda vez que uma função for chamada.</p>
      <hr>
      <h2 class="atx" id="passar-valores-para-funcoes-com-argumentos">Passar valores para funções com argumentos</h2>
      <p>Parâmetros&nbsp;são variáveis que atuam como espaços reservados para os valores que são passados para uma função, quando ela é chamada. Quando uma função é definida, normalmente ela é definida junto com um ou mais parâmetros. Os valores reais que são entradas de (ou&nbsp;"passadas"&nbsp;para) uma função quando ela é chamada são conhecidos como&nbsp;argumentos.</p>
      <p>Aqui está uma função com dois parâmetros,&nbsp;<code>param1</code>&nbsp;e&nbsp;<code>param2</code>:</p>
      <pre><code class="fenced-code-block language-js">function testFun(param1, param2) {
        console.log(param1, param2);
      }</code></pre>
      <p>Então podemos chamar o&nbsp;<code>testFun</code>&nbsp;dessa forma:&nbsp;<code>testFun("Hello", "World");</code>. Passamos dois argumentos do tipo string,&nbsp;<code>Hello</code>&nbsp;e&nbsp;<code>World</code>. Dentro da função,&nbsp;<code>param1</code>&nbsp;será igual à string&nbsp;<code>Hello</code>&nbsp;e&nbsp;<code>param2</code>&nbsp;será igual à string&nbsp;<code>World</code>. Note que você poderia chamar o&nbsp;<code>testFun</code>&nbsp;novamente com diferentes argumentos e os parâmetros assumiriam o valor dos novos argumentos.</p>
      <hr>
      <h2 class="atx" id="retornar-um-valor-de-uma-funcao-com-return">Retornar um valor de uma função com return</h2>
      <p>Nós podemos passar valores para uma função com&nbsp;argumentos. Você pode usar uma instrução&nbsp;<code>return</code>&nbsp;para enviar um valor para fora de uma função.</p>
      <p><strong>Exemplo</strong></p>
      <pre><code class="fenced-code-block language-js">function plusThree(num) {
        return num + 3;
      }
      const answer = plusThree(5);</code></pre>
      <p><code>answer</code>&nbsp;tem o valor de&nbsp;<code>8</code>.</p>
      <p><code>plusThree</code>&nbsp;recebe um&nbsp;argumento&nbsp;para&nbsp;<code>num</code>&nbsp;e retorna um valor igual a&nbsp;<code>num + 3</code>.</p>
      <hr>
      <h2 class="atx" id="conhecer-o-escopo-global-e-funcoes">Conhecer o escopo global e funções</h2>
      <p>Em JavaScript,&nbsp;escopo&nbsp;refere-se à visibilidade de variáveis. Variáveis que são definidas fora de um bloco de função tem o escopo&nbsp;Global. Isso significa que elas podem ser vistas em qualquer lugar no seu código JavaScript.</p>
      <p>Variáveis que são declaradas sem a palavra-chave&nbsp;<code>let</code>&nbsp;ou&nbsp;<code>const</code>&nbsp;são automaticamente criadas no escopo&nbsp;<code>global</code>. Isso pode criar consequências indesejadas em outro lugar no seu código ou quando executar uma função novamente. Você sempre deve declarar suas variáveis com&nbsp;<code>let</code>&nbsp;ou&nbsp;<code>const</code>.</p>
      <hr>
      <h2 class="atx" id="conhecer-o-escopo-local-e-funcoes">Conhecer o escopo local e funções</h2>
      <p>Variáveis que são declaradas dentro de uma função, assim como parâmetros das funções, possuem escopo&nbsp;local. Isso significa que elas são visíveis apenas dentro da função.</p>
      <p>Aqui está uma função&nbsp;<code>myTest</code>&nbsp;com uma variável local chamada&nbsp;<code>loc</code>.</p>
      <pre><code class="fenced-code-block language-js">function myTest() {
        const loc = "foo";
        console.log(loc);
      }
      myTest();
      console.log(loc);</code></pre>
      <p>A chamada da função&nbsp;<code>myTest()</code>&nbsp;vai exibir a string&nbsp;<code>foo</code>&nbsp;no console. A linha&nbsp;<code>console.log(loc)</code>&nbsp;(fora da função&nbsp;<code>myTest</code>) vai lançar um erro, já que&nbsp;<code>loc</code>&nbsp;não foi definido fora da função.</p>
      <hr>
      <h2 class="atx" id="difrerenciar-o-escopo-global-e-local-com-funcoes">Difrerenciar o escopo global e local com funções</h2>
      <p>É possível ter as variáveis&nbsp;local&nbsp;e&nbsp;global&nbsp;com o mesmo nome. Quando você faz isso, a variável local tem precedência sobre a variável global.</p>
      <p>Neste exemplo:</p>
      <pre><code class="fenced-code-block language-js">const someVar = "Hat";
      function myFun() {
        const someVar = "Head";
        return someVar;
      }</code></pre>
      <p>A função&nbsp;<code>myFun</code>&nbsp;retornará a string&nbsp;<code>Head</code>&nbsp;porque a versão local da variável está presente.</p>
      <hr>
      <h2 class="atx" id="entender-o-valor-undefined-retornado-de-uma-funcao">Entender o valor undefined retornado de uma função</h2>
      <p>Uma função pode incluir a instrução&nbsp;<code>return</code>&nbsp;mas ela não precisa fazer isso. No caso de a função não ter uma instrução&nbsp;<code>return</code>, quando você a chamar, a função processa o código interno, mas o valor retornado é&nbsp;<code>undefined</code>.</p>
      <p><strong>Exemplo</strong></p>
      <pre><code class="fenced-code-block language-js">let sum = 0;
      function addSum(num) {
        sum = sum + num;
      }
      addSum(3);</code></pre>
      <p><code>addSum</code>&nbsp;é uma função sem uma instrução&nbsp;<code>return</code>. A função vai alterar a variável global&nbsp;<code>sum</code>, mas o valor retornado da função é&nbsp;<code>undefined</code>.</p>
      <hr>
      <h2 class="atx" id="atribuir-com-o-valor-retornado">Atribuir com o valor retornado</h2>
      <p>Se você se lembrar de nossa discussão sobre como&nbsp;<a href="https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/basic-javascript/storing-values-with-the-assignment-operator">armazenar valores com o operador de atribuição</a>, tudo à direita do sinal de igual é resolvido antes de o valor ser atribuído. Isso significa que podemos pegar o valor de retorno de uma função e atribuí-lo a uma variável.</p>
      <p>Assuma que temos uma função predefinida chamada&nbsp;<code>sum</code>, que soma dois números. Então:</p>
      <pre><code class="fenced-code-block language-js">ourSum = sum(5, 12);</code></pre>
      <p>chamará a função&nbsp;<code>sum</code>, a qual retorna o valor&nbsp;<code>17</code>&nbsp;e então atribui este valor à variável&nbsp;<code>ourSum</code>.</p>
      <hr>
      <h2 class="atx" id="ficar-na-linha">Ficar na linha</h2>
      <p>Na Ciência da Computação, uma&nbsp;fila&nbsp;é uma&nbsp;estrutura de dados&nbsp;abstrata onde itens são mantidos em ordem. Novos itens podem ser adicionados no final da fila e itens mais antigos são removidos do início da fila.</p>
      <hr>
      <h2 class="atx" id="entender-valores-booleanos">Entender valores booleanos</h2>
      <p>Outro tipo de dado é o&nbsp;booleano. Booleanos podem ser apenas dois valores:&nbsp;<code>true</code>&nbsp;ou&nbsp;<code>false</code>. Eles basicamente são interruptores pequenos, onde&nbsp;<code>true</code>&nbsp;é ligado e&nbsp;<code>false</code>&nbsp;é desligado. Esses dois estados são mutuamente exclusivos.</p>
      <p><strong>Observação:</strong>&nbsp;valores booleanos nunca são escritos com aspas. As strings&nbsp;<code>"true"</code>&nbsp;e&nbsp;<code>"false"</code>&nbsp;não são booleanos e não tem nenhum significado especial em JavaScript.</p>
      <hr>
      <h2 class="atx" id="usar-logica-condicional-com-instrucoes-if">Usar lógica condicional com instruções if</h2>
      <p>instruções&nbsp;<code>if</code>&nbsp;são usadas para tomar decisões no código. A palavra-chave&nbsp;<code>if</code>&nbsp;diz ao JavaScript para executar o código nas chaves sob certas condições, definidas nos parênteses. Essas condições são conhecidas como condições&nbsp;<code>Boolean</code>&nbsp;e elas só podem ser&nbsp;<code>true</code>&nbsp;ou&nbsp;<code>false</code>.</p>
      <p>Quando a condição for&nbsp;<code>true</code>, o programa executará as instruções dentro das chaves. Quando a condição booleana for&nbsp;<code>false</code>, as instruções dentro das chaves não serão executadas.</p>
      <p><strong>Pseudocódigo</strong></p>
      <blockquote>
      <p>if (<em>condição é verdadeira</em>) {<br><em>instrução é executada</em><br>}</p>
      </blockquote>
      <p><strong>Exemplo</strong></p>
      <pre><code class="fenced-code-block language-js">function test (myCondition) {
        if (myCondition) {
          return "It was true";
        }
        return "It was false";
      }
      test(true);
      test(false);</code></pre>
      <p><code>test(true)</code>&nbsp;retorna a string&nbsp;<code>It was true</code>&nbsp;e&nbsp;<code>test(false)</code>&nbsp;retorna a string&nbsp;<code>It was false</code>.</p>
      <p>Quando&nbsp;<code>test</code>&nbsp;é chamado com o valor&nbsp;<code>true</code>, a instrução&nbsp;<code>if</code>&nbsp;avalia&nbsp;<code>myCondition</code>&nbsp;para verificar se é&nbsp;<code>true</code>&nbsp;ou não. Já que é&nbsp;<code>true</code>, a função retorna&nbsp;<code>It was true</code>. Quando chamamos&nbsp;<code>test</code>&nbsp;com um valor de&nbsp;<code>false</code>,&nbsp;<code>myCondition</code>&nbsp;<em>não é</em>&nbsp;<code>true</code>, a instrução nas chaves não é executada e a função retorna&nbsp;<code>It was false</code>.</p>
      <hr>
      <h2 class="atx" id="comparar-com-o-operador-de-igualdade">Comparar com o operador de igualdade</h2>
      <p>Há muitos&nbsp;operadores de comparação&nbsp;em JavaScript. Todos esses operadores retornam um valor booleano&nbsp;<code>true</code>&nbsp;ou&nbsp;<code>false</code>.</p>
      <p>O operador mais básico é o operador de igualdade&nbsp;<code>==</code>. O operador de igualdade compara dois valores e retorna&nbsp;<code>true</code>&nbsp;se eles são equivalentes ou&nbsp;<code>false</code>&nbsp;se não são. Observe que o operador de igualdade é diferente do operador de atribuição (<code>=</code>), que atribui o valor à direita do operador para uma variável à esquerda.</p>
      <pre><code class="fenced-code-block language-js">function equalityTest(myVal) {
        if (myVal == 10) {
          return "Equal";
        }
        return "Not Equal";
      }</code></pre>
      <p>Se&nbsp;<code>myVal</code>&nbsp;é igual a&nbsp;<code>10</code>, o operador de igualdade retorna&nbsp;<code>true</code>, assim o código nas chaves será executado e a função retornará&nbsp;<code>Equal</code>. Caso contrário, a função retornará&nbsp;<code>Not Equal</code>. Para que o JavaScript possa comparar dois&nbsp;tipos de dados&nbsp;diferentes (por exemplo,&nbsp;<code>numbers</code>&nbsp;e&nbsp;<code>strings</code>), deve converter um tipo para outro. Isto é conhecido como coerção de tipo (casting ou type coercion). No entanto, uma vez que a faça, você pode comparar os termos da seguinte forma:</p>
      <pre><code class="fenced-code-block language-js">1   ==  1  // true
      1   ==  2  // false
      1   == '1' // true
      "3" ==  3  // true</code></pre>
      <hr>
      <h2 class="atx" id="comparar-com-o-operador-de-igualdade-de-estrita">Comparar com o operador de igualdade de estrita</h2>
      <p>Igualdade estrita (<code>===</code>) é a contrapartida do operador de igualdade (<code>==</code>). No entanto, ao contrário do operador de igualdade, que tenta converter ambos os valores em comparação a um tipo comum, o operador estrito de igualdade não realiza uma conversão de tipo.</p>
      <p>Se os valores que são comparados tiverem valores diferentes, são considerados desiguais, e o operador de igualdade estrito retornará falso.</p>
      <p><strong>Exemplos</strong></p>
      <pre><code class="fenced-code-block language-js">3 ===  3  // true
      3 === '3' // false</code></pre>
      <p>No segundo exemplo,&nbsp;<code>3</code>&nbsp;é um tipo de&nbsp;<code>Number</code>&nbsp;e&nbsp;<code>'3'</code>&nbsp;é um tipo&nbsp;<code>String</code>.</p>
      <hr>
      <h2 class="atx" id="praticar-a-comparacao-de-diferentes-valores">Praticar a comparação de diferentes valores</h2>
      <p>Nos últimos dois desafios, aprendemos sobre o operador de igualdade (<code>==</code>) e o operador de igualdade estrita (<code>===</code>). Vamos fazer uma breve revisão e praticar usando esses operadores mais uma vez.</p>
      <p>Se os valores sendo comparados não são do mesmo tipo, o operador de igualdade fará a conversão de tipo e, então, avaliará os valores. No entanto, o operador de igualdade estrita vai comparar ambos os tipos de dados e os valores, sem converter de um tipo para outro.</p>
      <p><strong>Exemplos</strong></p>
      <p><code>3 == '3'</code>&nbsp;retorna&nbsp;<code>true</code>&nbsp;porque JavaScript faz a conversão de tipo de string para número.&nbsp;<code>3 === '3'</code>&nbsp;retorna&nbsp;<code>false</code>&nbsp;porque os tipos são diferentes e não é feita a conversão de tipo.</p>
      <p><strong>Observação:</strong>&nbsp;em JavaScript, você pode determinar o tipo de uma variável ou de um valor, com o operador&nbsp;<code>typeof</code>, como vemos a seguir:</p>
      <pre><code class="fenced-code-block language-js">typeof 3
      typeof '3'</code></pre>
      <p><code>typeof 3</code>&nbsp;retorna a string&nbsp;<code>number</code>&nbsp;e&nbsp;<code>typeof '3'</code>&nbsp;retorna a string&nbsp;<code>string</code>.</p>
      <hr>
      <h2 class="atx" id="comparar-com-o-operador-de-desigualdade">Comparar com o operador de desigualdade</h2>
      <p>O operador de desigualdade (<code>!=</code>) é o oposto do operador de igualdade. Significa que não é igual e retorna&nbsp;<code>false</code>&nbsp;onde a igualdade retornaria&nbsp;<code>true</code>&nbsp;e&nbsp;<em>vice-versa</em>. Tal como o operador de igualdade, o operador de desigualdade converterá os tipos de dados de valores enquanto compara.</p>
      <p><strong>Exemplos</strong></p>
      <pre><code class="fenced-code-block language-js">1 !=  2    // true
      1 != "1"   // false
      1 != '1'   // false
      1 != true  // false
      0 != false // false</code></pre>
      <hr>
      <h2 class="atx" id="comparar-com-o-operador-de-desigualdade-estrita">Comparar com o operador de desigualdade estrita</h2>
      <p>O operador de desigualdade estrito (<code>!==</code>) é o oposto lógico do operador de igualdade estrito. Significa que "não é estritamente igual" e retorna&nbsp;<code>false</code>&nbsp;onde a igualdade estrita retornaria&nbsp;<code>true</code>&nbsp;e&nbsp;<em>vice-versa</em>. O operador de desigualdade estrita não converterá tipos de dados.</p>
      <p><strong>Exemplos</strong></p>
      <pre><code class="fenced-code-block language-js">3 !==  3  // false
      3 !== '3' // true
      4 !==  3  // true</code></pre>
      <hr>
      <h2 class="atx" id="comparar-com-o-operador-maior-que">Comparar com o operador maior que</h2>
      <p>O operador maior que (<code>&gt;</code>) compara os valores de dois números. Se o número à esquerda for maior que o número à direita, ele retorna&nbsp;<code>true</code>. Caso contrário, ele retorna&nbsp;<code>false</code>.</p>
      <p>Tal como o operador de igualdade, o operador maior que converterá os tipos de dados de valores enquanto compara.</p>
      <p><strong>Exemplos</strong></p>
      <pre><code class="fenced-code-block language-js">5   &gt;  3  // true
      7   &gt; '3' // true
      2   &gt;  3  // false
      '1' &gt;  9  // false</code></pre>
      <hr>
      <h2 class="atx" id="comparar-com-o-operador-maior-ou-igual">Comparar com o operador maior ou igual</h2>
      <p>O operador maior ou igual que (<code>&gt;=</code>) compara os valores de dois números. Se o número à esquerda é maior ou igual ao número à direita, ele retorna&nbsp;<code>true</code>. Caso contrário, ele retornará&nbsp;<code>false</code>.</p>
      <p>Tal como o operador de igualdade, o operador maior que converterá os tipos de dados de valores enquanto compara.</p>
      <p><strong>Exemplos</strong></p>
      <pre><code class="fenced-code-block language-js">6   &gt;=  6  // true
      7   &gt;= '3' // true
      2   &gt;=  3  // false
      '7' &gt;=  9  // false</code></pre>
      <hr>
      <h2 class="atx" id="comparar-com-o-operador-menor-que">Comparar com o operador menor que</h2>
      <p>O operador menor que (<code>&lt;</code>) compara os valores de dois números. Se o número à esquerda for menos que o número à direita, retornará&nbsp;<code>true</code>. Caso contrário, retorna&nbsp;<code>false</code>. Assim como o operador de igualdade, o operador menor que converte os tipos de dados enquanto compara.</p>
      <p><strong>Exemplos</strong></p>
      <pre><code class="fenced-code-block language-js">2   &lt; 5 // true
      '3' &lt; 7 // true
      5   &lt; 5 // false
      3   &lt; 2 // false
      '8' &lt; 4 // false</code></pre>
      <hr>
      <h2 class="atx" id="comparar-com-o-operador-menor-ou-igual">Comparar com o operador menor ou igual</h2>
      <p>O operador menor ou igual (<code>&lt;=</code>) compara os valores de dois números. Se o número à esquerda for menor ou igual ao número à direita, retornará&nbsp;<code>true</code>. Se o número à esquerda for maior que o número a direita, retornará&nbsp;<code>false</code>. Assim como o operador de igualdade, o operador de menor ou igual que converte os tipos de dados.</p>
      <p><strong>Exemplos</strong></p>
      <pre><code class="fenced-code-block language-js">4   &lt;= 5 // true
      '7' &lt;= 7 // true
      5   &lt;= 5 // true
      3   &lt;= 2 // false
      '8' &lt;= 4 // false</code></pre>
      <hr>
      <h2 class="atx" id="comparar-com-o-operador-logico-and">Comparar com o operador lógico AND</h2>
      <p>Às vezes, você precisará testar mais de uma coisa de cada vez. O&nbsp;operador lógico AND&nbsp;(<code>&amp;&amp;</code>) retornará&nbsp;<code>true</code>&nbsp;apenas se os&nbsp;operadores&nbsp;à esquerda e à direita forem verdadeiros.</p>
      <p>O mesmo efeito pode ser alcançado aninhando uma instrução if dentro de outro if:</p>
      <pre><code class="fenced-code-block language-js">if (num &gt; 5) {
        if (num &lt; 10) {
          return "Yes";
        }
      }
      return "No";</code></pre>
      <p>só retornará&nbsp;<code>Yes</code>&nbsp;se&nbsp;<code>num</code>&nbsp;for maior que&nbsp;<code>5</code>&nbsp;e menor que&nbsp;<code>10</code>. A mesma lógica pode ser escrita assim:</p>
      <pre><code class="fenced-code-block language-js">if (num &gt; 5 &amp;&amp; num &lt; 10) {
        return "Yes";
      }
      return "No";</code></pre>
      <hr>
      <h2 class="atx" id="comparar-com-o-operador-logico-or">Comparar com o operador lógico OR</h2>
      <p>O&nbsp;operador lógico OR&nbsp;(<code>||</code>) retorna&nbsp;<code>true</code>&nbsp;se qualquer um dos&nbsp;operandos&nbsp;for&nbsp;<code>true</code>. Caso contrário, retorna&nbsp;<code>false</code>.</p>
      <p>O&nbsp;operador lógico ou&nbsp;é composto por dois símbolos de pipe: (<code>||</code>). Normalmente, ele pode ser encontrado entre as teclas Backspace e Enter.</p>
      <p>O padrão abaixo deve parecer familiar aos pontos das passagens anteriores:</p>
      <pre><code class="fenced-code-block language-js">if (num &gt; 10) {
        return "No";
      }
      if (num &lt; 5) {
        return "No";
      }
      return "Yes";</code></pre>
      <p>retornará&nbsp;<code>Yes</code>&nbsp;apenas se&nbsp;<code>num</code>&nbsp;for entre&nbsp;<code>5</code>&nbsp;e&nbsp;<code>10</code>&nbsp;(5 e 10 incluídos). A mesma lógica pode ser escrita assim:</p>
      <pre><code class="fenced-code-block language-js">if (num &gt; 10 || num &lt; 5) {
        return "No";
      }
      return "Yes";</code></pre>
      <hr>
      <h2 class="atx" id="introduzir-instrucoes-else">Introduzir instruções else</h2>
      <p>Quando uma condição para uma instrução&nbsp;<code>if</code>&nbsp;for verdadeira, o bloco de código seguinte será executado. E quando a condição for falsa? Normalmente, nada aconteceria. Com uma instrução&nbsp;<code>else</code>, um bloco de código alternativo pode ser executado.</p>
      <pre><code class="fenced-code-block language-js">if (num &gt; 10) {
        return "Bigger than 10";
      } else {
        return "10 or Less";
      }</code></pre>
      <hr>
      <h2 class="atx" id="introduzir-instrucoes-else-if">Introduzir instruções else if</h2>
      <p>Se você tem múltiplas condições que precisam ser resolvidas, você pode encadear as instruções&nbsp;<code>if</code>&nbsp;junto com instruções&nbsp;<code>else if</code>.</p>
      <pre><code class="fenced-code-block language-js">if (num &gt; 15) {
        return "Bigger than 15";
      } else if (num &lt; 5) {
        return "Smaller than 5";
      } else {
        return "Between 5 and 15";
      }</code></pre>
      <hr>
      <h2 class="atx" id="usar-a-ordem-logica-em-instrucoes-if-else">Usar a ordem lógica em instruções if else</h2>
      <p>A ordem é importante em instruções&nbsp;<code>if</code>&nbsp;e&nbsp;<code>else if</code>.</p>
      <p>A função é executada de cima para baixo, então você deve ser cuidadoso com qual instrução vem primeiro.</p>
      <p>Tomemos como exemplo estas duas funções.</p>
      <p>Aqui está a primeira:</p>
      <pre><code class="fenced-code-block language-js">function foo(x) {
        if (x &lt; 1) {
          return "Less than one";
        } else if (x &lt; 2) {
          return "Less than two";
        } else {
          return "Greater than or equal to two";
        }
      }</code></pre>
      <p>A segunda apenas altera a ordem das instruções if e else if:</p>
      <pre><code class="fenced-code-block language-js">function bar(x) {
        if (x &lt; 2) {
          return "Less than two";
        } else if (x &lt; 1) {
          return "Less than one";
        } else {
          return "Greater than or equal to two";
        }
      }</code></pre>
      <p>Embora as duas funções pareçam praticamente idênticas, se passarmos um número para ambas, teremos saídas diferentes.</p>
      <pre><code class="fenced-code-block language-js">foo(0)
      bar(0)</code></pre>
      <p><code>foo(0)</code>&nbsp;retornará a string&nbsp;<code>Less than one</code>&nbsp;e&nbsp;<code>bar(0)</code>&nbsp;retornará a string&nbsp;<code>Less than two</code>.</p>
      <hr>
      <h2 class="atx" id="encadear-instrucoes-if-else">Encadear instruções if else</h2>
      <p>Instruções&nbsp;<code>if/else</code>&nbsp;podem ser encadeadas por uma lógica complexa. Aqui está o&nbsp;pseudocódigo&nbsp;de várias instruções encadeadas&nbsp;<code>if</code>/<code>else if</code>:</p>
      <pre><code class="fenced-code-block language-js">if (condition1) {
        statement1
      } else if (condition2) {
        statement2
      } else if (condition3) {
        statement3
      . . .
      } else {
        statementN
      }</code></pre>
      <hr>
      <h2 class="atx" id="selecionar-entre-varias-opcoes-com-instrucoes-switch">Selecionar entre várias opções com instruções switch</h2>
      <p>Se você possui muitas opções pra escolher, use uma instrução&nbsp;switch. Uma instrução&nbsp;<code>switch</code>&nbsp;testa um valor e pode ter muitas instruções&nbsp;case&nbsp;as quais definem os diversos valores possíveis. As instruções são executadas desde o primeiro&nbsp;<code>case</code>&nbsp;correspondente até que seja encontrado um&nbsp;<code>break</code>.</p>
      <p>Aqui está um exemplo de uma instrução&nbsp;<code>switch</code>:</p>
      <pre><code class="fenced-code-block language-js">switch (lowercaseLetter) {
        case "a":
          console.log("A");
          break;
        case "b":
          console.log("B");
          break;
      }</code></pre>
      <p>Valores&nbsp;<code>case</code>&nbsp;são testados com o operador de igualdade estrita (<code>===</code>). O&nbsp;<code>break</code>&nbsp;diz ao JavaScript parar interromper a execução das instruções. Se o&nbsp;<code>break</code>&nbsp;for omitido, a próxima instrução case será executada.</p>
      <hr>
      <h2 class="atx" id="adicionar-uma-opcao-padrao-em-instrucoes-switch">Adicionar uma opção padrão em instruções switch</h2>
      <p>Na instrução&nbsp;<code>switch</code>, você não deve ser capaz de especificar todos os possíveis valores como instruções&nbsp;<code>case</code>. Ao invés disso, você pode adicionar a instrução&nbsp;<code>default</code>, que será executada se nenhuma instrução&nbsp;<code>case</code>&nbsp;correspondente for encontrada. Pense nisso como a instrução final&nbsp;<code>else</code>&nbsp;em uma cadeia de&nbsp;<code>if/else</code>.</p>
      <p>A instrução&nbsp;<code>default</code>&nbsp;deve ser o último caso.</p>
      <pre><code class="fenced-code-block language-js">switch (num) {
        case value1:
          statement1;
          break;
        case value2:
          statement2;
          break;
      ...
        default:
          defaultStatement;
          break;
      }</code></pre>
      <hr>
      <h2 class="atx" id="lidar-com-varias-opcoes-identicas-em-instrucoes-switch">Lidar com várias opções idênticas em instruções switch</h2>
      <p>Se a instrução&nbsp;<code>break</code>&nbsp;for omitida de uma instrução&nbsp;<code>case</code>&nbsp;de um&nbsp;<code>switch</code>, as instruções&nbsp;<code>case</code>&nbsp;seguintes serão executadas até que seja encontrado um&nbsp;<code>break</code>. Se você tem várias entradas com a mesma saída, você pode representá-las em uma instrução&nbsp;<code>switch</code>&nbsp;da seguinte forma:</p>
      <pre><code class="fenced-code-block language-js">let result = "";
      switch (val) {
        case 1:
        case 2:
        case 3:
          result = "1, 2, or 3";
          break;
        case 4:
          result = "4 alone";
      }</code></pre>
      <p>Todos os casos para 1, 2 e 3 vão produzir o mesmo resultado.</p>
      <hr>
      <h2 class="atx" id="substituir-cadeias-de-if-else-por-switch">Substituir cadeias de if else por switch</h2>
      <p>Se você tiver muitas opções para escolher, uma instrução&nbsp;<code>switch</code>&nbsp;pode ser mais fácil de escrever do que muitas instruções&nbsp;<code>if</code>/<code>else if</code>&nbsp;encadeadas. O seguinte:</p>
      <pre><code class="fenced-code-block language-js">if (val === 1) {
        answer = "a";
      } else if (val === 2) {
        answer = "b";
      } else {
        answer = "c";
      }</code></pre>
      <p>pode ser substituído por:</p>
      <pre><code class="fenced-code-block language-js">switch (val) {
        case 1:
          answer = "a";
          break;
        case 2:
          answer = "b";
          break;
        default:
          answer = "c";
      }</code></pre>
      <hr>
      <h2 class="atx" id="retornar-valores-booleanos-das-funcoes">Retornar valores booleanos das funções</h2>
      <p>Você pode se lembrar de&nbsp;<a href="https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/basic-javascript/comparison-with-the-equality-operator">Comparação com o operador de igualdade</a>, em que todos os operadores de comparação retornam um valor booleano&nbsp;<code>true</code>&nbsp;ou&nbsp;<code>false</code>.</p>
      <p>Às vezes, as pessoas usam uma instrução&nbsp;<code>if/else</code>&nbsp;para fazer uma comparação, dessa forma:</p>
      <pre><code class="fenced-code-block language-js">function isEqual(a, b) {
        if (a === b) {
          return true;
        } else {
          return false;
        }
      }</code></pre>
      <p>Mas há uma forma melhor de fazer isso. Já que&nbsp;<code>===</code>&nbsp;retorna&nbsp;<code>true</code>&nbsp;ou&nbsp;<code>false</code>, podemos retornar o resultado da comparação:</p>
      <pre><code class="fenced-code-block language-js">function isEqual(a, b) {
        return a === b;
      }</code></pre>
      <hr>
      <h2 class="atx" id="retornar-o-padrao-inicial-para-funcoes">Retornar o padrão inicial para funções</h2>
      <p>Quando uma instrução&nbsp;<code>return</code>&nbsp;é alcançada, a execução da função atual para e retorna o código para o local da chamada da função.</p>
      <p><strong>Exemplo</strong></p>
      <pre><code class="fenced-code-block language-js">function myFun() {
        console.log("Hello");
        return "World";
        console.log("byebye")
      }
      myFun();</code></pre>
      <p>O código acima exibirá no console a string&nbsp;<code>Hello</code>, e retorna a string&nbsp;<code>World</code>. A string&nbsp;<code>byebye</code>&nbsp;nunca vai ser exibida no console, porque a função termina na instrução&nbsp;<code>return</code>.</p>
      <hr>
      <h2 class="atx" id="criar-objetos-javascript">Criar objetos JavaScript</h2>
      <p>Você talvez tenha ouvido o termo&nbsp;<code>objeto</code>&nbsp;antes.</p>
      <p>Objetos são similares a&nbsp;<code>arrays</code>, exceto que, ao invés de usar índices para acessar e modificar seus dados, você acessa os dados em objetos através do que se chama&nbsp;<code>propriedades</code>.</p>
      <p>Objetos são úteis para armazenar dados de forma estruturada e podem representar objetos do mundo real, como um gato.</p>
      <p>Aqui está um exemplo de objeto gato:</p>
      <pre><code class="fenced-code-block language-js">const cat = {
        "name": "Whiskers",
        "legs": 4,
        "tails": 1,
        "enemies": ["Water", "Dogs"]
      };</code></pre>
      <p>Neste exemplo, todas as propriedades são armazenadas como strings, como&nbsp;<code>name</code>,&nbsp;<code>legs</code>&nbsp;e&nbsp;<code>tails</code>. Porém, você também pode usar números como propriedades. Você pode até omitir as aspas para propriedades de string com uma única palavra, da seguinte forma:</p>
      <pre><code class="fenced-code-block language-js">const anotherObject = {
        make: "Ford",
        5: "five",
        "model": "focus"
      };</code></pre>
      <p>No entanto, se seu objeto tem quaisquer propriedades que não sejam strings, o JavaScript automaticamente definirá seus tipos como strings.</p>
      <hr>
      <h2 class="atx" id="acessar-propriedades-de-objetos-com-notacao-de-pontos">Acessar propriedades de objetos com notação de pontos</h2>
      <p>Existem duas formas para acessar as propriedades de um objeto: notação de ponto (<code>.</code>) e notação de colchetes (<code>[]</code>), de forma similar a um array.</p>
      <p>Notação de ponto é o que você utiliza quando você sabe o nome da propriedade que você está tentando acessar antecipadamente.</p>
      <p>Aqui está um exemplo usando notação de ponto (<code>.</code>) para ler uma propriedade do objeto:</p>
      <pre><code class="fenced-code-block language-js">const myObj = {
        prop1: "val1",
        prop2: "val2"
      };
      const prop1val = myObj.prop1;
      const prop2val = myObj.prop2;</code></pre>
      <p><code>prop1val</code>&nbsp;teria o valor&nbsp;<code>val1</code>&nbsp;e&nbsp;<code>prop2val</code>&nbsp;teria o valor&nbsp;<code>val2</code>.</p>
      <hr>
      <h2 class="atx" id="acessar-propriedades-de-objeto-com-notacao-de-colchetes">Acessar propriedades de objeto com notação de colchetes</h2>
      <p>A segunda forma para acessar as propriedades de um objeto é a notação de colchetes (<code>[]</code>). Se a propriedade do objeto que você está tentando acessar possui um espaço no seu nome, você precisará usar a notação de colchetes.</p>
      <p>No entanto, você ainda pode usar a notação de colchetes nas propriedades dos objetos sem espaços.</p>
      <p>Aqui está um exemplo usando a notação de colchetes para ler uma propriedade de um objeto:</p>
      <pre><code class="fenced-code-block language-js">const myObj = {
        "Space Name": "Kirk",
        "More Space": "Spock",
        "NoSpace": "USS Enterprise"
      };
      myObj["Space Name"];
      myObj['More Space'];
      myObj["NoSpace"];</code></pre>
      <p><code>myObj["Space Name"]</code>&nbsp;seria a string&nbsp;<code>Kirk</code>,&nbsp;<code>myObj['More Space']</code>&nbsp;seria a string&nbsp;<code>Spock</code>&nbsp;e&nbsp;<code>myObj["NoSpace"]</code>&nbsp;seria a string&nbsp;<code>USS Enterprise</code>.</p>
      <p>Note que os nomes das propriedades com espaços neles precisam estar entre aspas (simples ou duplas).</p>
      <hr>
      <h2 class="atx" id="acessar-propriedades-de-objetos-com-variaveis">Acessar propriedades de objetos com variáveis</h2>
      <p>Outro uso de notação de colchetes em objetos é para acessar a propriedade a qual está armazenada como o valor de uma variável. Isso pode ser muito útil para iterar através das propriedades de um objeto ou quando acessando uma tabela de pesquisa.</p>
      <p>Aqui está um exemplo de usar uma variável para acessar uma propriedade:</p>
      <pre><code class="fenced-code-block language-js">const dogs = {
        Fido: "Mutt",
        Hunter: "Doberman",
        Snoopie: "Beagle"
      };
      const myDog = "Hunter";
      const myBreed = dogs[myDog];
      console.log(myBreed);</code></pre>
      <p>A string&nbsp;<code>Doberman</code>&nbsp;seria exibida no console.</p>
      <p>Observe que&nbsp;<em>não</em>&nbsp;usamos aspas em torno do nome da variável ao usá-la para acessar a propriedade, porque estamos usando o&nbsp;<em>valor</em>&nbsp;da variável, e não o&nbsp;<em>nome</em>.</p>
      <hr>
      <h2 class="atx" id="atualizar-propriedades-do-objeto">Atualizar propriedades do objeto</h2>
      <p>Depois de criar um objeto JavaScript, você pode atualizar suas propriedades a qualquer momento, como você atualizaria qualquer outra variável. Você pode usar notação de ponto ou colchete para atualizar.</p>
      <p>Por exemplo, vamos dar uma olhada em&nbsp;<code>ourDog</code>:</p>
      <pre><code class="fenced-code-block language-js">const ourDog = {
        "name": "Camper",
        "legs": 4,
        "tails": 1,
        "friends": ["everything!"]
      };</code></pre>
      <p>Como ele é um cachorro particularmente feliz, vamos mudar seu nome para o texto&nbsp;<code>Happy Camper</code>. Veja como atualizamos a propriedade name do objeto:&nbsp;<code>ourDog.name = "Happy Camper";</code>&nbsp;ou&nbsp;<code>ourDog["name"] = "Happy Camper";</code>&nbsp;Agora, quando avaliamos&nbsp;<code>ourDog.name</code>, em vez de obter&nbsp;<code>Camper</code>, teremos seu novo nome,&nbsp;<code>Happy Camper</code>.</p>
      <hr>
      <h2 class="atx" id="adicionar-novas-propriedades-para-um-objeto-javascript">Adicionar novas propriedades para um objeto JavaScript</h2>
      <p>Você pode adicionar novas propriedades para um objeto JavaScript existente da mesma forma pela qual você os modificaria.</p>
      <p>Aqui está como adicionaríamos uma propriedade&nbsp;<code>bark</code>&nbsp;para&nbsp;<code>ourDog</code>:</p>
      <pre><code class="fenced-code-block language-js">ourDog.bark = "bow-wow";</code></pre>
      <p>ou</p>
      <pre><code class="fenced-code-block language-js">ourDog["bark"] = "bow-wow";</code></pre>
      <p>Agora, quando acessamos&nbsp;<code>ourDog.bark</code>, nós teremos o seu latido,&nbsp;<code>bow-wow</code>.</p>
      <p>Exemplo:</p>
      <pre><code class="fenced-code-block language-js">const ourDog = {
        "name": "Camper",
        "legs": 4,
        "tails": 1,
        "friends": ["everything!"]
      };
      ourDog.bark = "bow-wow";</code></pre>
      <hr>
      <h2 class="atx" id="excluir-propriedades-de-um-objeto-javascript">Excluir propriedades de um objeto JavaScript</h2>
      <p>Podemos também excluir propriedades de objetos dessa forma:</p>
      <pre><code class="fenced-code-block language-js">delete ourDog.bark;</code></pre>
      <p>Exemplo:</p>
      <pre><code class="fenced-code-block language-js">const ourDog = {
        "name": "Camper",
        "legs": 4,
        "tails": 1,
        "friends": ["everything!"],
        "bark": "bow-wow"
      };
      delete ourDog.bark;</code></pre>
      <p>Após a última linha mostrada acima,&nbsp;<code>ourDog</code>&nbsp;se parece com:</p>
      <pre><code class="fenced-code-block language-js">{
        "name": "Camper",
        "legs": 4,
        "tails": 1,
        "friends": ["everything!"]
      }</code></pre>
      <hr>
      <h2 class="atx" id="usar-objetos-para-pesquisas">Usar objetos para pesquisas</h2>
      <p>Objetos podem ser pensados como armazenamento de chave/valor, como um dicionário. Se você tem um dado tabular, você pode usar um objeto para pesquisar valores ao invés de uma instrução&nbsp;<code>switch</code>&nbsp;ou uma cadeia de&nbsp;<code>if/else</code>. Isso é mais útil quando você sabe que o seu dado de entrada é limitado para um certo intervalo.</p>
      <p>Aqui está um exemplo de uma simples pesquisa reversa no alfabeto:</p>
      <pre><code class="fenced-code-block language-js">const alpha = {
        1:"Z",
        2:"Y",
        3:"X",
        4:"W",
        ...
        24:"C",
        25:"B",
        26:"A"
      };
      const thirdLetter = alpha[2];
      const lastLetter = alpha[24];
      const value = 2;
      const valueLookup = alpha[value];</code></pre>
      <p><code>thirdLetter</code>&nbsp;é a string&nbsp;<code>Y</code>,&nbsp;<code>lastLetter</code>&nbsp;é a string&nbsp;<code>C</code>&nbsp;e&nbsp;<code>valueLookup</code>&nbsp;é a string&nbsp;<code>Y</code>.</p>
      <hr>
      <h2 class="atx" id="testar-objetos-por-propriedades">Testar objetos por propriedades</h2>
      <p>Às vezes, é útil verificar se a propriedade de um determinado objeto existe ou não. Podemos usar o método de objetos&nbsp;<code>.hasOwnProperty(propname)</code>&nbsp;para determinar se aquele objeto possui o nome de propriedade fornecido.&nbsp;<code>.hasOwnProperty()</code>&nbsp;retorna&nbsp;<code>true</code>&nbsp;ou&nbsp;<code>false</code>&nbsp;se a propriedade for encontrada ou não.</p>
      <p><strong>Exemplo</strong></p>
      <pre><code class="fenced-code-block language-js">const myObj = {
        top: "hat",
        bottom: "pants"
      };
      myObj.hasOwnProperty("top");
      myObj.hasOwnProperty("middle");</code></pre>
      <p>O primeiro&nbsp;<code>hasOwnProperty</code>&nbsp;retorna&nbsp;<code>true</code>, enquanto o segundo retorna&nbsp;<code>false</code>.</p>
      <hr>
      <h2 class="atx" id="manipular-objetos-complexos">Manipular objetos complexos</h2>
      <p>Às vezes, você pode querer armazenar dados em uma&nbsp;Estrutura de Dados&nbsp;flexível. Um objeto JavaScript é uma forma de lidar com dados flexíveis. Eles permitem combinações arbitrárias de&nbsp;strings,&nbsp;numbers,&nbsp;booleans,&nbsp;arrays,&nbsp;functions&nbsp;e&nbsp;objects.</p>
      <p>Aqui está um exemplo de estrutura de dados complexas:</p>
      <pre><code class="fenced-code-block language-js">const ourMusic = [
        {
          "artist": "Daft Punk",
          "title": "Homework",
          "release_year": 1997,
          "formats": [
            "CD",
            "Cassette",
            "LP"
          ],
          "gold": true
        }
      ];</code></pre>
      <p>Este é um array que contém um objeto dentro dele. O objeto possui vários pedaços de&nbsp;metadados&nbsp;sobre um álbum. Também possui um array aninhado&nbsp;<code>formats</code>. Se você quiser adicionar mais álbuns, você pode fazer isso adicionando os discos ao array de alto nível. Objetos armazenam dados em uma propriedade, a qual possui um formato de chave-valor. No exemplo acima,&nbsp;<code>"artist": "Daft Punk"</code>&nbsp;é uma propriedade que tem uma chave&nbsp;<code>artist</code>&nbsp;e um valor de&nbsp;<code>Daft Punk</code>.</p>
      <p><strong>Observação:</strong>&nbsp;você precisará colocar uma vírgula após cada objeto no array, a não ser que ele seja o último objeto no array.</p>
      <hr>
      <h2 class="atx" id="acessar-objetos-aninhados">Acessar objetos aninhados</h2>
      <p>As subpropriedades de objetos podem ser acessadas ao encadear a notação de ponto e de colchetes.</p>
      <p>Aqui está um objeto aninhado:</p>
      <pre><code class="fenced-code-block language-js">const ourStorage = {
        "desk": {
          "drawer": "stapler"
        },
        "cabinet": {
          "top drawer": {
            "folder1": "a file",
            "folder2": "secrets"
          },
          "bottom drawer": "soda"
        }
      };
      ourStorage.cabinet["top drawer"].folder2;
      ourStorage.desk.drawer;</code></pre>
      <p><code>ourStorage.cabinet["top drawer"].folder2</code>&nbsp;seria a string&nbsp;<code>secrets</code>&nbsp;e&nbsp;<code>ourStorage.desk.drawer</code>&nbsp;seria a string&nbsp;<code>stapler</code>.</p>
      <hr>
      <h2 class="atx" id="acessar-arrays-aninhados">Acessar arrays aninhados</h2>
      <p>Como vimos em exemplos anteriores, objetos podem conter tanto objetos aninhados quanto arrays aninhados. Semelhante ao acesso de objetos aninhados, a notação de colchetes pode ser encadeada para se acessar arrays aninhados.</p>
      <p>Aqui está um exemplo de como se acessar um array aninhado:</p>
      <pre><code class="fenced-code-block language-js">const ourPets = [
        {
          animalType: "cat",
          names: [
            "Meowzer",
            "Fluffy",
            "Kit-Cat"
          ]
        },
        {
          animalType: "dog",
          names: [
            "Spot",
            "Bowser",
            "Frankie"
          ]
        }
      ];
      ourPets[0].names[1];
      ourPets[1].names[0];</code></pre>
      <p><code>ourPets[0].names[1]</code>&nbsp;seria a string&nbsp;<code>Fluffy</code>&nbsp;e&nbsp;<code>ourPets[1].names[0]</code>&nbsp;seria a string&nbsp;<code>Spot</code>.</p>
      <hr>
      <h2 class="atx" id="iterar-com-lacos-while-em-javascript">Iterar com laços while em JavaScript</h2>
      <p>Você pode rodar o mesmo código várias vezes usando um laço.</p>
      <p>O primeiro tipo de laço que aprenderemos é chamado de laço&nbsp;<code>while</code>&nbsp;porque ele rodará enquanto uma condição específica for verdadeira e vai parar uma vez que a condição não for mais verdadeira.</p>
      <pre><code class="fenced-code-block language-js">const ourArray = [];
      let i = 0;
      while (i &lt; 5) {
        ourArray.push(i);
        i++;
      }</code></pre>
      <p>No código de exemplo acima, o laço&nbsp;<code>while</code>&nbsp;executará por 5 vezes e adicionará os números de 0 até 4 a&nbsp;<code>ourArray</code>.</p>
      <p>Vamos tentar fazer um laço while funcionar empurrando valores para um array.</p>
      <hr>
      <h2 class="atx" id="iterar-com-lacos-for-em-javascript">Iterar com laços for em JavaScript</h2>
      <p>Você pode rodar o mesmo código várias vezes usando um laço.</p>
      <p>O tipo mais comum de laço JavaScript é chamado de laço&nbsp;<code>for</code>, porque ele é executado por um número especificado de vezes.</p>
      <p>Laços for são declarados com três expressões opcionais separadas por ponto e vírgula:</p>
      <p><code>for (a; b; c)</code>, onde&nbsp;<code>a</code>&nbsp;é a declaração de inicialização,&nbsp;<code>b</code>&nbsp;é a declaração de condição, e&nbsp;<code>c</code>&nbsp;é a expressão final.</p>
      <p>A declaração de inicialização é executada apenas uma vez antes de o laço iniciar. Normalmente, é usada para definir e configurar sua variável de laço.</p>
      <p>A declaração de condição é verificada no início de cada iteração do laço e vai continuar enquanto seu valor for&nbsp;<code>true</code>. Quando a condição for&nbsp;<code>false</code>&nbsp;no início da iteração, o laço vai parar de executar. Isso significa que se a condição de início for falsa, seu laço nunca será executado.</p>
      <p>A expressão final é executada no final de cada iteração do laço, antes da verificação da próxima condição e normalmente é usada para incrementar ou decrementar o contador do laço.</p>
      <p>No exemplo a seguir, inicializamos com&nbsp;<code>i = 0</code>&nbsp;e iteramos enquanto nossa condição&nbsp;<code>i &lt; 5</code>&nbsp;for verdadeira. Nós incrementaremos&nbsp;<code>i</code>&nbsp;em&nbsp;<code>1</code>&nbsp;em cada iteração do laço com&nbsp;<code>i++</code>&nbsp;como nossa expressão final.</p>
      <pre><code class="fenced-code-block language-js">const ourArray = [];
      for (let i = 0; i &lt; 5; i++) {
        ourArray.push(i);
      }</code></pre>
      <p><code>ourArray</code>&nbsp;agora terá o valor de&nbsp;<code>[0, 1, 2, 3, 4]</code>.</p>
      <hr>
      <h2 class="atx" id="iterar-numeros-impares-com-um-laco-for">Iterar números ímpares com um laço for</h2>
      <p>Laços for não tem de iterar um de cada vez. Ao alterar nossa&nbsp;<code>final-expression</code>, nós podemos contar os números pares.</p>
      <p>Começaremos em&nbsp;<code>i = 0</code>&nbsp;e um laço while&nbsp;<code>i &lt; 10</code>. Incrementaremos&nbsp;<code>i</code>&nbsp;em 2 a cada iteração com&nbsp;<code>i += 2</code>.</p>
      <pre><code class="fenced-code-block language-js">const ourArray = [];
      for (let i = 0; i &lt; 10; i += 2) {
        ourArray.push(i);
      }</code></pre>
      <p><code>ourArray</code>&nbsp;agora conterá&nbsp;<code>[0, 2, 4, 6, 8]</code>. Vamos mudar nossa&nbsp;<code>initialization</code>&nbsp;para que possamos contar por números ímpares.</p>
      <hr>
      <h2 class="atx" id="contar-pra-tras-com-um-laco-for">Contar pra trás com um laço for</h2>
      <p>Um laço for também pode contar pra trás, contanto que possamos definir as condições certas.</p>
      <p>Para decrementar em dois cada iteração, nós precisamos alterar nossa inicialização, condição e expressão final.</p>
      <p>Nós começaremos em&nbsp;<code>i = 10</code>&nbsp;e vamos iterar enquanto&nbsp;<code>i &gt; 0</code>. Nós decrementamos&nbsp;<code>i</code>&nbsp;por dois em cada iteração com&nbsp;<code>i -= 2</code>.</p>
      <pre><code class="fenced-code-block language-js">const ourArray = [];
      for (let i = 10; i &gt; 0; i -= 2) {
        ourArray.push(i);
      }</code></pre>
      <p><code>ourArray</code>&nbsp;agora vai conter&nbsp;<code>[10, 8, 6, 4, 2]</code>. Vamos mudar nossa inicialização e expressão final para que possamos contar para trás em dois para criar um array de números ímpares decrescentes.</p>
      <hr>
      <h2 class="atx" id="iterar-atraves-de-um-array-com-laco-for">Iterar através de um array com laço for</h2>
      <p>Uma tarefa comum em JavaScript é para iterar através do conteúdo de um array. Uma forma de fazer isso é com um laço&nbsp;<code>for</code>. Esse código vai exibir cada elemento do array&nbsp;<code>arr</code>&nbsp;no console:</p>
      <pre><code class="fenced-code-block language-js">const arr = [10, 9, 8, 7, 6];
      for (let i = 0; i &lt; arr.length; i++) {
        console.log(arr[i]);
      }</code></pre>
      <p>Lembre-se de que arrays têm indexação baseada em zero, o que significa que o último índice do array é de&nbsp;<code>length - 1</code>. Nossa condição para esse laço é&nbsp;<code>i &lt; arr.length</code>, que interrompe o laço quando&nbsp;<code>i</code>&nbsp;é igual a&nbsp;<code>length</code>. Nesse caso a última iteração é&nbsp;<code>i === 4</code>, ou seja, quando&nbsp;<code>i</code>&nbsp;se tornar igual a&nbsp;<code>arr.length - 1</code>&nbsp;e exibir&nbsp;<code>6</code>&nbsp;no console. Em seguida,&nbsp;<code>i</code>&nbsp;aumenta para&nbsp;<code>5</code>, e o laço é interrompido porque&nbsp;<code>i &lt; arr.length</code>&nbsp;é&nbsp;<code>false</code>.</p>
      <hr>
      <h2 class="atx" id="aninhar-lacos-for">Aninhar laços for</h2>
      <p>Se você possui um array multidimensional, você pode usar a mesma lógica no ponto de passagem anterior para iterar através de arrays e de qualquer sub-array. Exemplo:</p>
      <pre><code class="fenced-code-block language-js">const arr = [
        [1, 2], [3, 4], [5, 6]
      ];
      for (let i = 0; i &lt; arr.length; i++) {
        for (let j = 0; j &lt; arr[i].length; j++) {
          console.log(arr[i][j]);
        }
      }</code></pre>
      <p>Isso exibe no console cada subelemento dentro de&nbsp;<code>arr</code>, um de cada vez. Note que para o laço interno, nós estamos verificando a propriedade&nbsp;<code>.length</code>&nbsp;de&nbsp;<code>arr[i]</code>, desde que&nbsp;<code>arr[i]</code>&nbsp;também seja um array.</p>
      <hr>
      <h2 class="atx" id="iterar-com-lacos-dowhile-em-javascript">Iterar com laços do...while em JavaScript</h2>
      <p>O próximo tipo de laço que você aprenderá é chamado de laço&nbsp;<code>do...while</code>. O laço&nbsp;<code>do...while</code>&nbsp;é chamado assim porque primeiro fará algo (<code>do</code>) ou executará algo uma vez dentro do bloco de código, não importando o que acontecer. Em seguida, continuará a executar o laço enquanto (<code>while</code>) a condição for&nbsp;<code>true</code>.</p>
      <pre><code class="fenced-code-block language-js">const ourArray = [];
      let i = 0;
      do {
        ourArray.push(i);
        i++;
      } while (i &lt; 5);</code></pre>
      <p>O exemplo acima se comporta de forma similar a outros tipos de laços, e o array resultante se parecerá com&nbsp;<code>[0, 1, 2, 3, 4]</code>. No entanto, o que torna o laço&nbsp;<code>do...while</code>&nbsp;diferente de outros laços é como ele se comporta quando uma condição falha na primeira verificação. Vamos ver isso na prática. Aqui está um laço comum&nbsp;<code>while</code>&nbsp;que rodará o código no laço enquanto&nbsp;<code>i &lt; 5</code>:</p>
      <pre><code class="fenced-code-block language-js">const ourArray = [];
      let i = 5;
      while (i &lt; 5) {
        ourArray.push(i);
        i++;
      }</code></pre>
      <p>Nesse exemplo, inicializamos o valor de&nbsp;<code>ourArray</code>&nbsp;como um array vazio e o valor de&nbsp;<code>i</code>&nbsp;sendo 5. Quando executamos o laço&nbsp;<code>while</code>, a condição é igual a&nbsp;<code>false</code>&nbsp;porque&nbsp;<code>i</code>&nbsp;não é menor que 5, portanto nós não executamos o código dentro do laço. O resultado é que&nbsp;<code>ourArray</code>&nbsp;terminará sem valores adicionados a ele, e ainda se parecerá com&nbsp;<code>[]</code>&nbsp;quando todas as linhas do código no exemplo acima forem completamente executadas. Agora, dê uma olhada no laço&nbsp;<code>do...while</code>:</p>
      <pre><code class="fenced-code-block language-js">const ourArray = [];
      let i = 5;
      do {
        ourArray.push(i);
        i++;
      } while (i &lt; 5);</code></pre>
      <p>Nesse caso, nós inicializamos o valor de&nbsp;<code>i</code>&nbsp;para 5, assim como fizemos com o laço&nbsp;<code>while</code>. Quando chegamos na próxima linha, não há condição a ser analisada, então nós vamos ao código dentro das chaves e o executamos. Nós adicionaremos um único elemento ao array e então incrementamos&nbsp;<code>i</code>&nbsp;antes de chegarmos à verificação da condição. Quando nós finalmente temos o resultado da condição&nbsp;<code>i &lt; 5</code>&nbsp;na última linha, nós notamos que&nbsp;<code>i</code>&nbsp;agora é 6, o que não cumpre a verificação da condição, então nós saímos do laço e terminamos. Ao final do exemplo acima, o valor de&nbsp;<code>ourArray</code>&nbsp;é&nbsp;<code>[5]</code>. Essencialmente, um laço&nbsp;<code>do...while</code>&nbsp;garante que o código dentro do laço será executado pelo menos uma vez. Vamos tentar fazer um laço&nbsp;<code>do...while</code>&nbsp;funcionar inserindo valores em um array.</p>
      <hr>
      <h2 class="atx" id="substituir-lacos-usando-recursao">Substituir laços usando recursão</h2>
      <p>Recursão é o conceito de que uma função pode ser chamada por ela mesma. Para ajudar a entender isso, comece a pensar sobre a seguinte tarefa: multiplique os primeiros&nbsp;<code>n</code>&nbsp;elementos de um array para criar o produto desses elementos. Usando um laço&nbsp;<code>for</code>, você poderia fazer isso:</p>
      <pre><code class="fenced-code-block language-js">  function multiply(arr, n) {
          let product = 1;
          for (let i = 0; i &lt; n; i++) {
            product *= arr[i];
          }
          return product;
        }</code></pre>
      <p>No entanto, note que&nbsp;<code>multiply(arr, n) == multiply(arr, n - 1) * arr[n - 1]</code>. Isso significa que você pode reescrever&nbsp;<code>multiply</code>&nbsp;dentro da própria função e nunca precisar usar um laço.</p>
      <pre><code class="fenced-code-block language-js">  function multiply(arr, n) {
          if (n &lt;= 0) {
            return 1;
          } else {
            return multiply(arr, n - 1) * arr[n - 1];
          }
        }</code></pre>
      <p>A versão recursiva de&nbsp;<code>multiply</code>&nbsp;fica dessa forma. No&nbsp;caso de base, onde&nbsp;<code>n &lt;= 0</code>, ele retorna 1. Para valores maiores de&nbsp;<code>n</code>, a função chama a si mesma, mas com&nbsp;<code>n - 1</code>. Essa chamada da função é avaliada da mesma forma, chamando&nbsp;<code>multiply</code>&nbsp;novamente até que&nbsp;<code>n &lt;= 0</code>. Nesse ponto, todas as funções podem retornar e a função&nbsp;<code>multiply</code>&nbsp;original retorna a resposta.</p>
      <p><strong>Observação:</strong>&nbsp;funções recursivas precisam ter um caso de base quando elas retornam sem chamar a função novamente (nesse exemplo, quando&nbsp;<code>n &lt;= 0</code>), caso contrário, elas nunca vão parar de executar.</p>
      <hr>
      <h2 class="atx" id="gerar-fracoes-aleatorias-com-javascript">Gerar frações aleatórias com JavaScript</h2>
      <p>Números aleatórios são úteis para criar comportamento aleatório.</p>
      <p>JavaScript tem a função&nbsp;<code>Math.random()</code>&nbsp;que gera um número decimal aleatório entre&nbsp;<code>0</code>&nbsp;(incluso) e&nbsp;<code>1</code>&nbsp;(excluso). Assim,&nbsp;<code>Math.random()</code>&nbsp;pode retornar um&nbsp;<code>0</code>&nbsp;mas nunca retornará&nbsp;<code>1</code>.</p>
      <p><strong>Observação:</strong>&nbsp;como ao&nbsp;<a href="https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/basic-javascript/storing-values-with-the-assignment-operator">armazenar valores com operador de atribuição</a>, todas as chamadas de funções serão resolvidas antes de executar o&nbsp;<code>return</code>, para que possamos dar ao&nbsp;<code>return</code>&nbsp;o valor da função&nbsp;<code>Math.random()</code>.</p>
      <hr>
      <h2 class="atx" id="gerar-numeros-inteiros-aleatorios-com-javascript">Gerar números inteiros aleatórios com JavaScript</h2>
      <p>É ótimo podermos gerar números decimais aleatórios, mas é ainda mais útil se usarmos isso para gerar números inteiros aleatórios.</p>
      <ol>
      <li>Use&nbsp;<code>Math.random()</code>&nbsp;para gerar um decimal aleatório.</li>
      <li>Multiplique o decimal aleatório por&nbsp;<code>20</code>.</li>
      <li>Use outra função,&nbsp;<code>Math.floor()</code>&nbsp;para arredondar o número para baixo para o número inteiro mais próximo.</li>
      </ol>
      <p>Lembre-se de que&nbsp;<code>Math.random()</code>&nbsp;pode nunca retornar um&nbsp;<code>1</code>&nbsp;e, por estarmos arredondando, é impossível também receber&nbsp;<code>20</code>. Essa técnica nos dará um número inteiro entre&nbsp;<code>0</code>&nbsp;e&nbsp;<code>19</code>.</p>
      <p>Juntando tudo, é assim que nosso código se parece:</p>
      <pre><code class="fenced-code-block language-js">Math.floor(Math.random() * 20);</code></pre>
      <p>Nós estamos chamando&nbsp;<code>Math.random()</code>, multiplicando o resultado por 20, e em seguida passando o valor para a função&nbsp;<code>Math.floor()</code>&nbsp;para arredondar o valor para o número inteiro mais próximo abaixo.</p>
      <hr>
      <h2 class="atx" id="gerar-numeros-inteiros-aleatorios-dentro-de-um-intervalo">Gerar números inteiros aleatórios dentro de um intervalo</h2>
      <p>Ao invés de gerar um número inteiro aleatório entre 0 e um número especificado, como fizemos anteriormente, nós podemos gerar um número inteiro aleatório que fica em um intervalo entre dois números especificados.</p>
      <p>Para isso, definiremos um número mínimo&nbsp;<code>min</code>&nbsp;e um número máximo<code>max</code>.</p>
      <p>Aqui está a fórmula que usaremos. Leve um momento para ler e entender o que esse código está fazendo:</p>
      <pre><code class="fenced-code-block language-js">Math.floor(Math.random() * (max - min + 1)) + min</code></pre>
      <hr>
      <h2 class="atx" id="usar-a-funcao-parseint">Usar a função parseInt()</h2>
      <p>A função&nbsp;<code>parseInt()</code>&nbsp;analisa uma string e retorna um inteiro. Exemplo:</p>
      <pre><code class="fenced-code-block language-js">const a = parseInt("007");</code></pre>
      <p>A função acima converte a string&nbsp;<code>007</code>&nbsp;para o inteiro&nbsp;<code>7</code>. Se o primeiro caractere na string não pode ser convertido em um número, então ele retorna&nbsp;<code>NaN</code>.</p>
      <hr>
      <h2 class="atx" id="usar-a-funcao-parseint-com-um-radix">Usar a função parseInt com um radix</h2>
      <p>A função&nbsp;<code>parseInt()</code>&nbsp;analisa uma string e retorna um inteiro. É preciso um segundo argumento para o radix, que especifica a base do número na string. O radix pode ser um inteiro entre 2 e 36.</p>
      <p>A chamada da função se parece com:</p>
      <pre><code class="fenced-code-block language-js">parseInt(string, radix);</code></pre>
      <p>Exemplo:</p>
      <pre><code class="fenced-code-block language-js">const a = parseInt("11", 2);</code></pre>
      <p>A variável radix diz que&nbsp;<code>11</code>&nbsp;está no sistema binário, ou base 2. Esse exemplo converte a string&nbsp;<code>11</code>&nbsp;para um inteiro&nbsp;<code>3</code>.</p>
      <hr>
      <h2 class="atx" id="usar-o-operador-condicional-ternario">Usar o operador condicional (ternário)</h2>
      <p>O&nbsp;operador condicional, também chamado de&nbsp;operador ternário, pode ser usado como uma expressão if-else de uma linha.</p>
      <p>A sintaxe é&nbsp;<code>a ? b : c</code>, onde&nbsp;<code>a</code>&nbsp;é a condição,&nbsp;<code>b</code>&nbsp;é o código executado quando a condição retorna&nbsp;<code>true</code>&nbsp;e&nbsp;<code>c</code>&nbsp;é o código executado quando a condição retorna&nbsp;<code>false</code>.</p>
      <p>A função a seguir usa a instrução&nbsp;<code>if/else</code>&nbsp;para verificar uma condição:</p>
      <pre><code class="fenced-code-block language-js">function findGreater(a, b) {
        if(a &gt; b) {
          return "a is greater";
        }
        else {
          return "b is greater or equal";
        }
      }</code></pre>
      <p>Isto pode ser reescrito usando o operador condicional:</p>
      <pre><code class="fenced-code-block language-js">function findGreater(a, b) {
        return a &gt; b ? "a is greater" : "b is greater or equal";
      }</code></pre>
      <hr>
      <h2 class="atx" id="usar-operadores-de-multiplas-condicoes-ternarios">Usar operadores de múltiplas condições (ternários)</h2>
      <p>No desafio anterior, você usou um único operador condicional. Você também pode encadear eles juntos para verificar por múltiplas condições.</p>
      <p>A seguinte função usa as instruções&nbsp;<code>if</code>,&nbsp;<code>else if</code>&nbsp;e&nbsp;<code>else</code>&nbsp;para verificar múltiplas condições:</p>
      <pre><code class="fenced-code-block language-js">function findGreaterOrEqual(a, b) {
        if (a === b) {
          return "a and b are equal";
        }
        else if (a &gt; b) {
          return "a is greater";
        }
        else {
          return "b is greater";
        }
      }</code></pre>
      <p>A função acima pode ser rescrita usando operadores de múltiplas condições (operador ternário):</p>
      <pre><code class="fenced-code-block language-js">function findGreaterOrEqual(a, b) {
        return (a === b) ? "a and b are equal"
          : (a &gt; b) ? "a is greater"
          : "b is greater";
      }</code></pre>
      <p>É considerada a melhor prática para formatar operadores de múltiplas condições, já que cada condição está em uma linha separada, como mostrado acima. Usar operadores de múltiplas condições sem a indentação adequada pode dificultar a leitura do seu código. Por exemplo:</p>
      <pre><code class="fenced-code-block language-js">function findGreaterOrEqual(a, b) {
        return (a === b) ? "a and b are equal" : (a &gt; b) ? "a is greater" : "b is greater";
      }</code></pre>
    </main>
  </div>

</body>
</html>